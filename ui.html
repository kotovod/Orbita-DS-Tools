<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orbita DS ✦ Tools</title>
  <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0nMTYnIGhlaWdodD0nMTYnIHZpZXdCb3g9JzAgMCAxNiAxNicgZmlsbD0nbm9uZScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJz48ZyBjbGlwLXBhdGg9J3VybCgjY2xpcDBfNTMxXzI3MDMpJz48cGF0aCBmaWxsLXJ1bGU9J2V2ZW5vZGQnIGNsaXAtcnVsZT0nZXZlbm9kZCcgZD0nTTggMEM5LjU2NTk5IDQuNjc0MTdlLTA3IDEwLjkyMDQgMS44MDAxMyAxMS41NzcxIDQuNDIxODhDMTQuMTk5NSA1LjA3ODQ3IDE2IDYuNDMzNzkgMTYgOEMxNiA5LjU2NjE3IDE0LjE5OTQgMTAuOTIwNSAxMS41NzcxIDExLjU3NzFDMTAuOTIwNSAxNC4xOTk0IDkuNTY2MTcgMTYgOCAxNkM2LjQzMzc5IDE2IDUuMDc4NDcgMTQuMTk5NSA0LjQyMTg4IDExLjU3NzFDMS44MDAxMyAxMC45MjA0IDAgOS41NjU5OSAwIDhDMCA2LjQzMzk3IDEuOCA1LjA3ODU2IDQuNDIxODggNC40MjE4OEM1LjA3ODU2IDEuOCA2LjQzMzk3IDYuODQ1MzRlLTA4IDggMFpNOS4zODQ3NyAxMS45Mzg1QzguOTM0OTIgMTEuOTc3NyA4LjQ3MjMyIDEyIDggMTJDNy41MjczNSAxMiA3LjA2NDQxIDExLjk3NzggNi42MTQyNiAxMS45Mzg1QzYuNzIwMTEgMTIuMjM5MSA2LjgzNjA2IDEyLjUxNDkgNi45NTk5NiAxMi43NjI3QzcuMjM4NTQgMTMuMzE5OCA3LjUxODc0IDEzLjY2MjMgNy43MzQzOCAxMy44NDQ3QzcuODM3MzUgMTMuOTMxOCA3LjkxMTYyIDEzLjk3MDEgNy45NTExNyAxMy45ODYzQzcuOTcwNjUgMTMuOTk0MyA3Ljk4MzM1IDEzLjk5NzggNy45ODkyNiAxMy45OTlDNy45OTQ4IDE0LjAwMDEgNy45OTc5IDE0IDggMTRDOC4wMDIxIDE0IDguMDA1MiAxNC4wMDAxIDguMDEwNzQgMTMuOTk5QzguMDE2NjUgMTMuOTk3OCA4LjAyOTM1IDEzLjk5NDMgOC4wNDg4MyAxMy45ODYzQzguMDg4MzggMTMuOTcwMSA4LjE2MjY1IDEzLjkzMTggOC4yNjU2MiAxMy44NDQ3QzguNDgxMjYgMTMuNjYyMyA4Ljc2MTQ2IDEzLjMxOTggOS4wNDAwNCAxMi43NjI3QzkuMTYzOSAxMi41MTUgOS4yNzg5NCAxMi4yMzg5IDkuMzg0NzcgMTEuOTM4NVpNOCA2QzYuODk1NDMgNiA2IDYuODk1NDMgNiA4QzYgOS4xMDQ1NyA2Ljg5NTQzIDEwIDggMTBDOS4xMDQ1NyAxMCAxMCA5LjEwNDU3IDEwIDhDMTAgNi44OTU0MyA5LjEwNDU3IDYgOCA2Wk00LjA2MDU1IDYuNjE0MjZDMy43NjAzMSA2LjcyMDAzIDMuNDg0ODggNi44MzYxNyAzLjIzNzMgNi45NTk5NkMyLjY4MDE2IDcuMjM4NTQgMi4zMzc2OSA3LjUxODc0IDIuMTU1MjcgNy43MzQzOEMyLjA2ODE3IDcuODM3MzUgMi4wMjk4OSA3LjkxMTYyIDIuMDEzNjcgNy45NTExN0MyLjAwNTcgNy45NzA2NSAyLjAwMjE4IDcuOTgzMzUgMi4wMDA5OCA3Ljk4OTI2QzEuOTk5ODYgNy45OTQ4IDIgNy45OTc5IDIgOEMyIDguMDAyMSAxLjk5OTg2IDguMDA1MiAyLjAwMDk4IDguMDEwNzRDMi4wMDIxOCA4LjAxNjY1IDIuMDA1NyA4LjAyOTM1IDIuMDEzNjcgOC4wNDg4M0MyLjAyOTg5IDguMDg4MzggMi4wNjgxNyA4LjE2MjY1IDIuMTU1MjcgOC4yNjU2MkMyLjMzNzY5IDguNDgxMjYgMi42ODAxNiA4Ljc2MTQ2IDMuMjM3MyA5LjA0MDA0QzMuNDg0NzkgOS4xNjM3OCAzLjc2MDQzIDkuMjc5MDMgNC4wNjA1NSA5LjM4NDc3QzQuMDIxMyA4LjkzNDk1IDQgOC40NzIyOSA0IDhDNCA3LjUyNzM3IDQuMDIxMjQgNy4wNjQzOCA0LjA2MDU1IDYuNjE0MjZaTTExLjkzODUgNi42MTQyNkMxMS45Nzc4IDcuMDY0NDEgMTIgNy41MjczNCAxMiA4QzEyIDguNDcyMzIgMTEuOTc3NyA4LjkzNDkyIDExLjkzODUgOS4zODQ3N0MxMi4yMzg5IDkuMjc4OTQgMTIuNTE1IDkuMTYzOSAxMi43NjI3IDkuMDQwMDRDMTMuMzE5OCA4Ljc2MTQ2IDEzLjY2MjMgOC40ODEyNiAxMy44NDQ3IDguMjY1NjJDMTMuOTMxOCA4LjE2MjY1IDEzLjk3MDEgOC4wODgzOCAxMy45ODYzIDguMDQ4ODNDMTMuOTk0MyA4LjAyOTM1IDEzLjk5NzggOC4wMTY2NSAxMy45OTkgOC4wMTA3NEMxNC4wMDAxIDguMDA1MiAxNCA4LjAwMjEgMTQgOEMxNCA3Ljk5NzkgMTQuMDAwMSA3Ljk5NDggMTMuOTk5IDcuOTg5MjZDMTMuOTk3OCA3Ljk4MzM1IDEzLjk5NDMgNy45NzA2NSAxMy45ODYzIDcuOTUxMTdDMTMuOTcwMSA3LjkxMTYyIDEzLjkzMTggNy44MzczNSAxMy44NDQ3IDcuNzM0MzhDMTMuNjYyMyA3LjUxODc0IDEzLjMxOTggNy4yMzg1NCAxMi43NjI3IDYuOTU5OTZDMTIuNTE0OSA2LjgzNjA2IDEyLjIzOTEgNi43MjAxMSAxMS45Mzg1IDYuNjE0MjZaTTcuOTg5MjYgMi4wMDA5OEM3Ljk4MzM1IDIuMDAyMTggNy45NzA2NSAyLjAwNTcgNy45NTExNyAyLjAxMzY3QzcuOTExNjIgMi4wMjk4OSA3LjgzNzM1IDIuMDY4MTcgNy43MzQzOCAyLjE1NTI3QzcuNTE4NzQgMi4zMzc2OSA3LjIzODU0IDIuNjgwMTYgNi45NTk5NiAzLjIzNzNDNi44MzYxNyAzLjQ4NDg4IDYuNzIwMDMgMy43NjAzMSA2LjYxNDI2IDQuMDYwNTVDNy4wNjQzOCA0LjAyMTI0IDcuNTI3MzcgNCA4IDRDOC40NzIyOSA0IDguOTM0OTUgNC4wMjEzIDkuMzg0NzcgNC4wNjA1NUM5LjI3OTAzIDMuNzYwNDMgOS4xNjM3OCAzLjQ4NDc5IDkuMDQwMDQgMy4yMzczQzguNzYxNDYgMi42ODAxNiA4LjQ4MTI2IDIuMzM3NjkgOC4yNjU2MiAyLjE1NTI3QzguMTYyNjUgMi4wNjgxNyA4LjA4ODM4IDIuMDI5ODkgOC4wNDg4MyAyLjAxMzY3QzguMDI5MzUgMi4wMDU3IDguMDE2NjUgMi4wMDIxOCA4LjAxMDc0IDIuMDAwOThDOC4wMDUyIDEuOTk5ODYgOC4wMDIxIDIgOCAyQzcuOTk3OSAyIDcuOTk0OCAxLjk5OTg2IDcuOTg5MjYgMi4wMDA5OFonIGZpbGw9J3doaXRlJy8+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD0nY2xpcDBfNTMxXzI3MDMnPjxyZWN0IHdpZHRoPScxNicgaGVpZ2h0PScxNicgZmlsbD0nd2hpdGUnLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4K">
  
  <!-- JSZip library for creating ZIP archives - попробуем другой CDN -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  
  <!-- Network Error Handler -->
  <script>
    // Global error handler for network requests
    window.addEventListener('error', function(event) {
      // Ignore Statsig analytics errors that don't affect plugin functionality
      if (event.target && event.target.src && event.target.src.includes('statsigapi.net')) {
        console.warn('Ignoring Statsig analytics error (does not affect plugin functionality):', event.target.src);
        event.preventDefault();
        return false;
      }
      
      // Ignore other external analytics errors
      if (event.target && event.target.src && (
        event.target.src.includes('analytics') || 
        event.target.src.includes('tracking') ||
        event.target.src.includes('telemetry')
      )) {
        console.warn('Ignoring analytics error (does not affect plugin functionality):', event.target.src);
        event.preventDefault();
        return false;
      }
    });

    // Handle unhandled promise rejections from network requests
    window.addEventListener('unhandledrejection', function(event) {
      if (event.reason && event.reason.message && (
        event.reason.message.includes('statsigapi.net') ||
        event.reason.message.includes('ERR_NAME_NOT_RESOLVED')
      )) {
        console.warn('Ignoring network error (does not affect plugin functionality):', event.reason.message);
        event.preventDefault();
        return false;
      }
    });

    // Override fetch to handle network errors gracefully
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
      return originalFetch.apply(this, args).catch(error => {
        // Ignore Statsig and analytics errors
        if (error.message && (
          error.message.includes('statsigapi.net') ||
          error.message.includes('ERR_NAME_NOT_RESOLVED') ||
          error.message.includes('analytics')
        )) {
          console.warn('Ignoring network error (does not affect plugin functionality):', error.message);
          return Promise.resolve(new Response('{}', { status: 200 }));
        }
        throw error;
      });
    };
  </script>
  <style>
    body {
      font-family: 'Inter', 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #34343C;
      color: #FFFFFF;
      font-size: 14px;
      line-height: 1.5;
      overflow-y: auto;
      overflow-x: hidden;
      max-height: 100vh;
      min-height: 100vh;
      width: 100%;
    }

    html {
      background-color: #34343C;
      margin: 0;
      padding: 0;
      height: 100%;
    }

    /* Убираем любые белые просветы */
    .header-container,
    .content-container,
    .button-container {
      background-color: inherit;
    }

    /* Iframe в Figma должен иметь правильный фон */
    * {
      box-sizing: border-box;
    }
    
    /* Стилизация scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background-color: #34343c;
      border-radius: 0px;
    }
    
    ::-webkit-scrollbar-thumb {
      background-color: #505059;
      border-radius: 0px;
      transition: background-color 0.3s ease;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background-color: #F86025;
    }
    
    ::-webkit-scrollbar-corner {
      background-color: #34343C;
    }
    
    /* Базовые анимации */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideInDown {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-5px); }
      60% { transform: translateY(-2px); }
    }
    
    /* Анимация для символа в заголовке */
    @keyframes starSpin {
      0% { transform: scale(1) rotate(0deg); color: #F86025; }
      25% { transform: scale(1.5) rotate(90deg); color: #FFD700; }
      50% { transform: scale(2) rotate(180deg); color: #FF9168; }
      75% { transform: scale(1.5) rotate(270deg); color: #F86025; }
      100% { transform: scale(1) rotate(360deg); color: #F86025; }
    }
    
    @keyframes starGlow {
      0% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
      50% { text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 138, 101, 0.6); }
      100% { text-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
    }
    
    @keyframes starColor {
      0% { color: #F86025; }
      25% { color: #FFD700; }
      50% { color: #FF9168; }
      75% { color: #F86025; }
      100% { color: #F86025; }
    }
    
    /* Классы для анимаций */
    .animate-fadeIn {
      animation: fadeIn 0.25s ease forwards;
    }
    
    .animate-slideIn {
      animation: slideInDown 0.25s ease forwards;
    }
    
    .animate-pulse {
      animation: pulse 0.5s ease infinite;
    }
    
    .star-animation {
      display: inline-block;
      animation: starSpin 3s ease-in-out, starGlow 3s ease-in-out, starColor 3s ease-in-out;
      animation-iteration-count: 1;
      transform-origin: center;
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
    }
    
    .header-container {
      position: sticky;
      top: 0;
      background-color: #34343C;
      padding: 8px 16px 24px 16px;
      z-index: 10;
    }
    
    .content-container {
      padding: 0 16px;
    }
    
    .badge {
      display: none; /* По умолчанию скрыт, будет показан только при наличии ошибок */
      align-items: center;
      justify-content: center;
      background-color: #F02D2D;
      color: white;
      border-radius: 12px;
      min-width: 16px;
      height: 24px;
      padding: 0 8px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 8px;
      position: relative;
      z-index: 5;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    button {
      background-color: #F86025;
      color: white;
      border: none;
      border-radius: 12px;
      padding: 8px 9px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 16px;
      position: relative;
      overflow: hidden;
    }
    
    button:after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 5px;
      height: 5px;
      background: rgba(255, 255, 255, 0.5);
      opacity: 0;
      border-radius: 100%;
      transform: scale(1, 1) translate(-50%);
      transform-origin: 50% 50%;
    }
    
    button:focus:not(:active)::after {
      animation: ripple 1s ease-out;
    }
    
    @keyframes ripple {
      0% {
        transform: scale(0, 0);
        opacity: 0.5;
      }
      20% {
        transform: scale(25, 25);
        opacity: 0.3;
      }
      100% {
        opacity: 0;
        transform: scale(40, 40);
      }
    }

    .primary-button {
      width: 100%;
    }

    .secondary-button {
      background-color: #44444C;
      font-size: 12px;
      padding: 12px 8px;
      margin: 0 4px 0 0;
    }

    .fix-button {
      background-color: #505059;
      font-size: 12px;
      padding: 4px;
      margin-left: 8px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .fix-button svg {
      width: 24px;
      height: 24px;
    }
    
    .fix-button .tooltip {
      position: absolute;
      visibility: hidden;
      width: 150px;
      background-color: #222228;
      color: #FFFFFF;
      text-align: center;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 12px;
      z-index: 2000; /* Увеличиваем z-index до 2000, как и у других тултипов */
      bottom: 125%; /* Всегда показываем тултип над кнопкой */
      left: 50%;
      margin-left: -75px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      border: 1px solid #44444C;
    }
    
    .fix-button:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    button:hover {
      background-color: #E55520;
      /* transform: translateY(-2px); */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    button:active {
      background-color: #D24A1B;
      /* transform: translateY(0); */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .secondary-button:hover {
      background-color: #55555C;
    }

    .fix-button:hover {
      background-color: #E55520;
      animation: pulse 0.5s ease;
    }

    .results-container {
      margin-top: 0px;
      margin-bottom: 16px;
    }


    .error-item {
      background-color: #44444C;
      border-radius: 12px;
      padding: 6px 12px;
      margin-bottom: 6px;
    }

    .component-name {
      font-weight: 600;
      margin-bottom: 8px;
      color: #F86025;
      cursor: pointer;
      text-decoration: underline;
      display: inline-block;
    }

    .component-name:hover {
      color: #E55520;
    }

    .parent-name {
      font-size: 12px;
      color: #AAAAAA;
      margin-bottom: 8px;
    }

    .error-list {
      list-style-type: none;
      padding-left: 0;
      margin: 0;
    }

    .error-list li {
      padding: 0;
      border-bottom: 1px solid #505059;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }

    .error-message {
      flex: 1;
      display: flex;
      align-items: center;
    }
    
    .tooltip-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #55555C;
      color: rgb(161, 161, 161);
      font-size: 10px;
      margin-left: 8px;
      cursor: help;
      position: relative;
    }
    
    .tooltip {
      position: absolute;
      visibility: hidden;
      width: 250px;
      background-color: #222228;
      color: #FFFFFF;
      text-align: left;
      border-radius: 12px;
      padding: 8px;
      font-size: 12px;
      line-height: 1.4;
      z-index: 2000; /* Значительно увеличиваем z-index, чтобы tooltip отображался поверх всех элементов */
      bottom: 125%; /* Всегда показываем тултип над элементом */
      left: 50%;
      margin-left: -125px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      border: 1px solid #44444C;
    }
    
    .tooltip-icon:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    .error-list li:last-child {
      border-bottom: none;
    }

    .no-errors {
      text-align: center;
      padding: 24px;
      color: #AAAAAA;
    }

    .loading {
      text-align: center;
      padding: 12px;
      color: #FFFFFF;
    }
    
    .progress-container {
      margin: 16px 0;
    }
    
    .progress-bar {
      width: 100%;
      height: 8px;
      background-color: #44444C;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #F86025, #FF8B4A);
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s infinite;
    }
    
    .progress-text {
      margin-top: 8px;
      font-size: 12px;
      color: #AAAAAA;
      text-align: center;
    }
    
    .error-message {
      background-color: #505059;
      color: #FFFFFF;
      padding: 6px 12px;
      border-radius: 8px;
      margin-bottom: 8px;
    }

    .success-message {
      background-color: #2D5F3D;
      color: #FFFFFF;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 16px;
    }

    .button-container {
      display: flex;
      margin-bottom: 0px;
      gap: 8px;
    }
    
    .check-button {
      flex-grow: 1;
    }

    .tertiary-button {
      width: 200px;
      height: 40px;
      padding: 0;
      display: block;
      justify-content: center;
      align-items: center;
      background-color: #44444C;
    }
    
    .settings-button {
      width: 80px;
      height: 40px;
      padding: 0;
      display: block;
      justify-content: center;
      align-items: center;
      background-color: #44444C;
    }
    
    .settings-icon {
      width: 20px;
      height: 20px;
      fill: white;
    }

    .settings-dropdown {
      background-color: #44444C;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 16px;
      display: none;
      transform-origin: top center;
      transition: all 0.3s ease-out;
      opacity: 0;
    }
    
    .settings-dropdown.show {
      opacity: 1;
      transform: scaleY(1);
    }

    .settings-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      position: relative;
    }
    
    .dependent-item {
      margin-left: 20px;
      position: relative;
    }
    
    .dependent-item::before {
      content: "└";
      position: absolute;
      left: -15px;
      color: #666;
    }
    
    .settings-divider {
      height: 1px;
      background-color: #55555C;
      margin: 12px 0;
    }
    
    .all-checks-item {
      font-weight: 500;
    }
    
    /* Стили для кастомных чекбоксов */
    .settings-item input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      height: 0;
      width: 0;
    }
    
    .settings-item label {
      position: relative;
      padding-left: 28px;
      cursor: pointer;
      display: inline-block;
      line-height: 20px;
    }
    
    .settings-item label:before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      width: 20px;
      height: 20px;
      border-radius: 8px;
      background-color: #b5b7c040;
      transition: background-color 0.2s ease;
    }
    
    .settings-item input[type="checkbox"]:checked + label:before {
      background-color: #ff9168;
    }
    
    .settings-item input[type="checkbox"]:checked + label:after {
      content: '';
      position: absolute;
      left: 4px;
      top: 4px;
      width: 12px;
      height: 12px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' focusable='false' aria-hidden='true' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='white' d='m11.43 3.807-6.155 6.428-4.203-4.21 1.062-1.06L5.253 8.09l5.094-5.32z'%3E%3C/path%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
    }

    .settings-item:last-child {
      margin-bottom: 0;
    }

    /* Стили для Node ID Inspector */
    .node-id-section {
      background-color: #44444C;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 16px;
      display: none; /* Скрыт по умолчанию, показывается только в режиме node-id-inspector */
    }

    /* Стили для AI Design Lint */
    .ai-design-lint-section {
      display: none; /* Скрыт по умолчанию, показывается только в режиме ai-design-lint */
    }
    
    .ai-design-lint-mode .ai-design-lint-section {
      display: block;
      margin-bottom: 0;
    }

    /* ============================================
       УНИФИЦИРОВАННАЯ СИСТЕМА СТИЛЕЙ (v3.1)
       Эталон: Check Icons UI
       ============================================ */
    
    /* Унифицированный Header */
    .unified-header {
      position: sticky;
      top: 0;
      background-color: #34343C;
      padding: 8px 16px 24px 16px;
      z-index: 10;
    }
    
    .unified-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
    }
    
    .unified-badge {
      display: none;
      align-items: center;
      justify-content: center;
      background-color: #F02D2D;
      color: white;
      border-radius: 12px;
      min-width: 16px;
      height: 24px;
      padding: 0 8px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    /* Унифицированные Кнопки */
    .unified-button {
      background-color: #F86025;
      color: white;
      border: none;
      border-radius: 12px;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .unified-button:hover {
      background-color: #E55520;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .unified-button:active {
      background-color: #D24A1B;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .unified-button-primary {
      width: 100%;
      margin-bottom: 16px;
    }
    
    .unified-button-secondary {
      background-color: #44444C;
      font-size: 12px;
      padding: 12px 8px;
      margin: 0 4px 16px 0;
    }
    
    .unified-button-secondary:hover {
      background-color: #55555C;
    }
    
    .unified-button-tertiary {
      background-color: #505059;
      font-size: 12px;
      padding: 8px 12px;
    }
    
    .unified-button-tertiary:hover {
      background-color: #E55520;
    }
    
    /* Контейнер кнопок */
    .unified-button-group {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    /* Унифицированный Progress Bar */
    .unified-progress-container {
      margin: 16px 0;
    }
    
    .unified-progress-bar {
      width: 100%;
      height: 8px;
      background-color: #44444C;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .unified-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #F86025, #FF8B4A);
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .unified-progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s infinite;
    }
    
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    .unified-progress-text {
      margin-top: 8px;
      font-size: 12px;
      color: #AAAAAA;
      text-align: center;
    }
    
    /* Унифицированные Карточки Результатов */
    .unified-results-container {
      margin-top: 0;
      margin-bottom: 16px;
    }
    
    .unified-card {
      background-color: #44444C;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 8px;
      transition: background-color 0.2s ease;
    }
    
    .unified-card:hover {
      background-color: #4A4A54;
    }
    
    .unified-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .unified-card-title {
      font-weight: 600;
      color: #F86025;
      cursor: pointer;
      text-decoration: underline;
    }
    
    .unified-card-title:hover {
      color: #E55520;
    }
    
    .unified-card-subtitle {
      font-size: 12px;
      color: #AAAAAA;
      margin-bottom: 8px;
    }
    
    .unified-card-content {
      font-size: 13px;
      color: #FFFFFF;
      line-height: 1.5;
    }
    
    /* Унифицированные Списки */
    .unified-list {
      list-style-type: none;
      padding-left: 0;
      margin: 0;
    }
    
    .unified-list-item {
      padding: 8px 0;
      border-bottom: 1px solid #505059;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }
    
    .unified-list-item:last-child {
      border-bottom: none;
    }
    
    /* Унифицированные Сообщения */
    .unified-message {
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
      text-align: center;
    }
    
    .unified-message-success {
      background-color: #2D5F3D;
      color: #FFFFFF;
    }
    
    .unified-message-error {
      background-color: #5C2D2D;
      color: #FFFFFF;
    }
    
    .unified-message-warning {
      background-color: #5C4D2D;
      color: #FFFFFF;
    }
    
    .unified-message-info {
      background-color: #2D3F5C;
      color: #FFFFFF;
    }
    
    /* Унифицированные Input'ы */
    .unified-input {
      width: 100%;
      background-color: #44444C;
      border: 1px solid #505059;
      border-radius: 8px;
      padding: 8px 12px;
      color: #FFFFFF;
      font-size: 14px;
      margin-bottom: 12px;
      transition: border-color 0.2s ease;
    }
    
    .unified-input:focus {
      outline: none;
      border-color: #F86025;
    }
    
    .unified-input::placeholder {
      color: #AAAAAA;
    }
    
    .unified-textarea {
      width: 100%;
      background-color: #44444C;
      border: 1px solid #505059;
      border-radius: 8px;
      padding: 8px 12px;
      color: #FFFFFF;
      font-size: 14px;
      margin-bottom: 12px;
      resize: vertical;
      min-height: 80px;
      font-family: 'Inter', 'Roboto', sans-serif;
    }
    
    .unified-textarea:focus {
      outline: none;
      border-color: #F86025;
    }
    
    /* Унифицированные Label'ы */
    .unified-label {
      display: block;
      font-size: 12px;
      color: #AAAAAA;
      margin-bottom: 8px;
      font-weight: 500;
    }
    
    /* Унифицированные Select'ы */
    .unified-select {
      width: 100%;
      background-color: #44444C;
      border: 1px solid #505059;
      border-radius: 8px;
      padding: 8px 12px;
      color: #FFFFFF;
      font-size: 14px;
      margin-bottom: 12px;
      cursor: pointer;
    }
    
    .unified-select:focus {
      outline: none;
      border-color: #F86025;
    }
    
    /* Унифицированные Checkbox'ы и Radio */
    .unified-checkbox-group,
    .unified-radio-group {
      margin-bottom: 16px;
    }
    
    .unified-checkbox-item,
    .unified-radio-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      cursor: pointer;
    }
    
    .unified-checkbox-item input[type="checkbox"],
    .unified-radio-item input[type="radio"] {
      margin-right: 8px;
      cursor: pointer;
    }
    
    .unified-checkbox-item label,
    .unified-radio-item label {
      font-size: 14px;
      color: #FFFFFF;
      cursor: pointer;
    }
    
    /* Унифицированный Tooltip */
    .unified-tooltip-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #55555C;
      color: #A1A1A1;
      font-size: 10px;
      margin-left: 8px;
      cursor: help;
      position: relative;
    }
    
    .unified-tooltip {
      position: absolute;
      visibility: hidden;
      width: 250px;
      background-color: #222228;
      color: #FFFFFF;
      text-align: left;
      border-radius: 12px;
      padding: 8px;
      font-size: 12px;
      line-height: 1.4;
      z-index: 2000;
      bottom: 125%;
      left: 50%;
      margin-left: -125px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      border: 1px solid #44444C;
    }
    
    .unified-tooltip-icon:hover .unified-tooltip {
      visibility: visible;
      opacity: 1;
    }
    
    /* Унифицированное состояние Loading */
    .unified-loading {
      text-align: center;
      padding: 24px;
      color: #AAAAAA;
    }
    
    .unified-loading-spinner {
      display: inline-block;
      width: 32px;
      height: 32px;
      border: 3px solid #44444C;
      border-top-color: #F86025;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Унифицированное состояние Empty */
    .unified-empty {
      text-align: center;
      padding: 48px 24px;
      color: #AAAAAA;
    }
    
    .unified-empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    
    .unified-empty-text {
      font-size: 14px;
    }
    
    /* Унифицированные Секции */
    .unified-section {
      margin-bottom: 24px;
    }
    
    .unified-section-title {
      font-size: 14px;
      font-weight: 600;
      color: #FFFFFF;
      margin-bottom: 12px;
    }
    
    /* Разделитель */
    .unified-divider {
      height: 1px;
      background-color: #505059;
      margin: 16px 0;
    }
    
    /* Вспомогательные классы */
    .unified-text-small {
      font-size: 12px;
    }
    
    .unified-text-muted {
      color: #AAAAAA;
    }
    
    .unified-text-primary {
      color: #F86025;
    }
    
    .unified-text-center {
      text-align: center;
    }
    
    .unified-mt-8 { margin-top: 8px; }
    .unified-mt-16 { margin-top: 16px; }
    .unified-mb-8 { margin-bottom: 8px; }
    .unified-mb-16 { margin-bottom: 16px; }
    .unified-p-12 { padding: 12px; }
    .unified-p-16 { padding: 16px; }
    
    /* ============================================
       КОНЕЦ УНИФИЦИРОВАННОЙ СИСТЕМЫ
       ============================================ */

    /* Стили для Design System Validator */
    .design-system-validator-section {
      display: none; /* Скрыт по умолчанию, показывается только в режиме design-system-validator */
    }
    
    .design-system-validator-mode .design-system-validator-section {
      display: block;
      margin-bottom: 0;
    }
    
    /* Кнопка настроек */
    .settings-button:hover svg path {
      stroke: #FFFFFF;
    }
    
    .settings-button:active {
      transform: scale(0.95);
    }
    
    /* Кнопка назад */
    .back-button:hover svg path {
      stroke: #FFFFFF;
    }
    
    .back-button:active {
      transform: scale(0.95);
    }
    
    .ai-analysis-result {
      background-color: #44444C;
      border-radius: 12px;
      padding: 12px;
      margin-top: 16px;
      max-height: 400px;
      overflow-y: auto;
    }
    
    .ai-analysis-result h4 {
      font-size: 13px;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: #F86025;
    }
    
    .ai-analysis-result p {
      font-size: 12px;
      line-height: 1.6;
      color: #FFFFFF;
      margin-bottom: 8px;
    }
    
    .ai-analysis-result ul {
      list-style-type: none;
      padding-left: 0;
      margin: 8px 0;
    }
    
    .ai-analysis-result li {
      font-size: 12px;
      line-height: 1.6;
      color: #FFFFFF;
      padding: 6px 0;
      border-bottom: 1px solid #505059;
    }
    
    .ai-analysis-result li:last-child {
      border-bottom: none;
    }
    
    .ai-analysis-result li::before {
      content: "•";
      color: #F86025;
      font-weight: bold;
      display: inline-block;
      width: 1em;
      margin-right: 8px;
    }
    
    .ai-loading {
      text-align: center;
      padding: 24px;
      color: #AAAAAA;
      font-size: 12px;
    }
    
    .ai-loading::after {
      content: "...";
      animation: dots 1.5s steps(4, end) infinite;
    }
    
    /* Новые стили для компонентов анализа */
    .analysis-score-panel {
      background: linear-gradient(135deg, #44444C 0%, #3A3A42 100%);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid #505059;
    }

    .score-display {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .score-number {
      font-size: 32px;
      font-weight: 700;
      color: #F86025;
      line-height: 1;
    }

    .score-label {
      font-size: 12px;
      color: #AAAAAA;
      margin-top: 4px;
    }

    .score-breakdown {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .score-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #505059;
    }

    .score-item:last-child {
      border-bottom: none;
    }

    .score-item-label {
      font-size: 11px;
      color: #FFFFFF;
    }

    .score-item-value {
      font-size: 11px;
      font-weight: 600;
      color: #F86025;
    }

    .analysis-section {
      background-color: #44444C;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .analysis-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .analysis-section-title {
      font-size: 13px;
      font-weight: 600;
      color: #FFFFFF;
    }

    .analysis-section-toggle {
      background: none;
      border: none;
      color: #AAAAAA;
      cursor: pointer;
      font-size: 12px;
      padding: 4px;
    }

    .analysis-section-content {
      font-size: 12px;
      color: #FFFFFF;
    }

    .hardcoded-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid #505059;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .hardcoded-item:hover {
      background-color: #505059;
    }

    .hardcoded-item:active {
      background-color: #F86025;
      color: white;
    }

    .hardcoded-item:last-child {
      border-bottom: none;
    }

    .hardcoded-info {
      flex: 1;
    }

    .hardcoded-type {
      font-size: 11px;
      color: #F86025;
      font-weight: 600;
    }

    .hardcoded-description {
      font-size: 11px;
      color: #AAAAAA;
      margin-top: 2px;
    }

    .hardcoded-value {
      font-size: 11px;
      color: #FFFFFF;
      font-family: 'SF Mono', 'Monaco', monospace;
    }

    .token-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #505059;
      border-radius: 4px;
      transition: all 0.15s ease;
    }

    .token-item:last-child {
      border-bottom: none;
    }
    
    .token-item:hover {
      background-color: rgba(76, 175, 80, 0.1);
      transform: translateX(2px);
    }

    .token-info {
      flex: 1;
    }

    .token-name {
      font-size: 11px;
      color: #4CAF50;
      font-weight: 600;
    }

    .token-type {
      font-size: 11px;
      color: #AAAAAA;
      margin-top: 2px;
    }

    .recommendation-item {
      padding: 8px 0;
      border-bottom: 1px solid #505059;
    }

    .recommendation-item:last-child {
      border-bottom: none;
    }

    .recommendation-priority {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      margin-right: 8px;
    }

    .recommendation-priority.high {
      background-color: #F44336;
      color: white;
    }

    .recommendation-priority.medium {
      background-color: #FF9800;
      color: white;
    }

    .recommendation-priority.low {
      background-color: #4CAF50;
      color: white;
    }

    .recommendation-message {
      font-size: 12px;
      color: #FFFFFF;
      margin-top: 4px;
    }

    .token-suggestion-item {
      padding: 8px;
      border-bottom: 1px solid #505059;
      border-radius: 4px;
      transition: all 0.15s ease;
    }

    .token-suggestion-item:last-child {
      border-bottom: none;
    }
    
    .token-suggestion-item:hover {
      background-color: rgba(248, 96, 37, 0.1);
      transform: translateX(2px);
    }

    .suggestion-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .suggestion-hardcoded {
      font-size: 11px;
      color: #F86025;
      font-weight: 600;
    }

    .suggestion-confidence {
      font-size: 10px;
      color: #4CAF50;
      background: #2A2A32;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .suggestion-token {
      font-size: 11px;
      color: #4CAF50;
      font-weight: 600;
      margin: 4px 0;
    }

    .suggestion-reason {
      font-size: 10px;
      color: #AAAAAA;
      font-style: italic;
    }
    
    @keyframes dots {
      0%, 20% { content: "."; }
      40% { content: ".."; }
      60%, 100% { content: "..."; }
    }
    
    /* Стили для режима Node ID Inspector */
    .node-id-mode .node-id-section {
      display: block;
      margin-bottom: 0;
    }
    
    .node-id-mode .node-id-section h3 {
      margin-top: 0;
    }

    /* Стили для SVG Export */
    .svg-export-section {
      /* background-color: #44444C;
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 16px; */
      display: none; /* Скрыт по умолчанию, показывается только в режиме svg-export */
    }
    
    /* Стили для режима SVG Export */
    .svg-export-mode .svg-export-section {
      display: block;
      margin-bottom: 0;
    }
    
    .svg-export-mode .svg-export-section h3 {
      margin-top: 0;
    }

    /* Стили для Component Properties Export */
    .component-properties-export-section {
      display: none; /* Скрыт по умолчанию, показывается только в режиме component-properties-export */
    }
    
    /* Стили для режима Component Properties Export */
    .component-properties-export-mode .component-properties-export-section {
      display: block;
      margin-bottom: 0;
    }
    
    .component-properties-export-mode .component-properties-export-section h3 {
      margin-top: 0;
    }

    /* Стили для Get Page Text */
    .get-page-text-section {
      display: none; /* Скрыт по умолчанию, показывается только в режиме get-page-text */
    }
    
    /* Стили для режима Get Page Text */
    .get-page-text-mode .get-page-text-section {
      display: block;
      margin-bottom: 0;
    }
    
    .get-page-text-mode .get-page-text-section h3 {
      margin-top: 0;
    }

    /* Стили для анализа компонентов */
    .export-analysis {
      background-color: #2A2A32;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .analysis-header h4 {
      margin: 0 0 12px 0;
      color: #FFFFFF;
      font-size: 14px;
    }

    .analysis-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 16px;
    }

    .stat-item {
      background-color: #1A1A1F;
      border-radius: 6px;
      padding: 8px;
      text-align: center;
    }

    .stat-label {
      font-size: 11px;
      color: #8A8A8A;
      display: block;
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 16px;
      font-weight: 600;
      color: #FFFFFF;
    }

    .analysis-details {
      font-size: 12px;
      color: #CCCCCC;
    }

    .analysis-details h5 {
      margin: 8px 0 4px 0;
      color: #FFFFFF;
      font-size: 12px;
    }

    .analysis-details ul {
      margin: 4px 0;
      padding-left: 16px;
    }

    .analysis-details li {
      margin: 2px 0;
    }

    /* Стили для детального прогрессбара Component Properties Export */
    .component-properties-export-mode .export-progress {
      background-color: #2A2A32;
      border-radius: 8px;
      padding: 16px;
      margin-top: 12px;
    }

    .export-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .export-counter {
      font-size: 12px;
      color: #8A8A8A;
      font-weight: 500;
    }

    .export-progress-bar {
      width: 100%;
      height: 8px;
      background-color: #1A1A1F;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .export-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #F86025, #FF8A50);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .export-progress-details {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .progress-info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }

    .export-speed {
      color: #4CAF50;
      font-weight: 500;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
    }

    .export-time-info {
      display: flex;
      justify-content: space-between;
      width: 100%;
      font-size: 11px;
      color: #B0B0B0;
    }

    .export-elapsed-time {
      color: #4CAF50;
    }

    .export-remaining-time {
      color: #FF9800;
    }

    .export-progress-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .export-percentage {
      font-size: 12px;
      color: #F86025;
      font-weight: 600;
      min-width: 35px;
    }

    .export-current-item {
      font-size: 11px;
      color: #CCCCCC;
      font-style: italic;
    }

    .export-stats {
      background-color: #44444C;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .stats-item:last-child {
      margin-bottom: 0;
    }

    .stats-label {
      color: #fff;
    }

    .stats-value {
      color: #fff;
      font-weight: 600;
    }

    .export-info {
      background-color: #44444C;
      border-radius: 8px;
      padding: 8px;
      margin-top: 8px;
    }

    .export-info code {
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
      font-size: 11px;
    }

    /* Стили для выбора цвета fill */
    .color-options {
      background-color: #44444C;
      border-radius: 8px;
      padding: 12px 12px 6px 12px;
    }

    .color-preset-buttons {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .color-preset-btn {
      flex: 1;
      padding: 6px 8px;
      border: none;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      /* transition: all 0.2s ease; */
    }

    .color-preset-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .color-preset-btn.active {
      box-shadow: 0 0 0 2px #F86025;
    }

    .custom-color-input input[type="text"] {
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
    }

    .custom-color-input input[type="text"]:focus {
      outline: none;
      border-color: #F86025;
      box-shadow: 0 0 0 1px rgba(248, 96, 37, 0.3);
    }

    .custom-color-input input[type="text"].has-color {
      border-left: 3px solid var(--selected-color, #F86025);
    }

    /* Стили для детального прогрессбара SVG экспорта */
    .svg-export-progress {
      background-color: #2A2A32;
      border-radius: 8px;
      padding: 16px;
      margin-top: 12px;
    }

    .export-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .export-progress-header span {
      font-size: 13px;
      font-weight: 500;
    }

    .export-counter {
      color: #F86025 !important;
      font-weight: 600;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
    }

    .export-progress-bar {
      background-color: #505059;
      border-radius: 6px;
      height: 8px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .export-progress-fill {
      background: linear-gradient(90deg, #F86025, #FF8B4A);
      height: 100%;
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 6px;
      position: relative;
      overflow: hidden;
    }

    .export-progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .export-progress-details {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
    }

    .export-percentage {
      color: #F86025;
      font-weight: 600;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
    }

    .export-current-icon {
      color: #AAAAAA;
      font-style: italic;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
      max-width: 200px;
    }

    .node-ids-textarea {
      width: 100%;
      min-height: 80px;
      background-color: #2A2A32;
      border: 1px solid #505059;
      border-radius: 8px;
      padding: 8px;
      color: #FFFFFF;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
      font-size: 11px;
      line-height: 1.4;
      resize: vertical;
      box-sizing: border-box;
    }

    .node-ids-textarea:focus {
      outline: none;
      border-color: #F86025;
      box-shadow: 0 0 0 2px rgba(248, 96, 37, 0.2);
    }

    .node-ids-textarea::placeholder {
      color: #AAAAAA;
    }

    .current-node-id {
      word-break: break-all;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
    }

    .comparison-result {
      background-color: #2A2A32;
      border-radius: 8px;
      padding: 8px;
      margin-top: 8px;
      font-size: 12px;
      line-height: 1.4;
    }

    .comparison-result.match {
      background-color: #2D5F3D;
      color: #FFFFFF;
    }

    .comparison-result.no-match {
      background-color: #5F2D2D;
      color: #FFFFFF;
    }

    .comparison-result.info {
      background-color: #505059;
      color: #FFFFFF;
    }

  </style>
</head>
<body style="background-color: #34343C;">
  <div class="header-container">
    <div style="display: flex; align-items: center;">
      <h1>
        Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;Tools
      </h1>
      <span id="error-badge" class="badge">0</span>
    </div>
    
    <div class="button-container">
      <button id="check-button" class="primary-button check-button">Проверить</button>
      <button id="create-cell-button" class="tertiary-button" title="Создать Cell с компонентом">Создать Cell</button>
      <button id="settings-button" class="settings-button" title="Что будем проверять">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M5.75195 8.00196C5.90055 8.00417 6.04242 8.00868 6.17285 8.01758C6.45841 8.03707 6.79738 8.0831 7.14844 8.22852C7.88321 8.53299 8.46701 9.11679 8.77148 9.85157C8.9169 10.2026 8.96294 10.5416 8.98242 10.8272C8.99136 10.9582 8.99584 11.1007 8.99805 11.25H16V12.75H8.99805C8.99584 12.8993 8.99136 13.0419 8.98242 13.1729C8.96294 13.4584 8.9169 13.7974 8.77148 14.1484C8.46701 14.8832 7.88321 15.467 7.14844 15.7715C6.79738 15.9169 6.45841 15.9629 6.17285 15.9824C5.91182 16.0002 5.60499 16 5.29004 16H4.70996C4.39501 16 4.08818 16.0002 3.82715 15.9824C3.54159 15.9629 3.20263 15.9169 2.85156 15.7715C2.11679 15.467 1.53299 14.8832 1.22852 14.1484C1.0831 13.7974 1.03706 13.4584 1.01758 13.1729L1.00195 12.75H0V11.25H1.00195C1.00416 11.1007 1.00864 10.9582 1.01758 10.8272C1.03706 10.5416 1.0831 10.2026 1.22852 9.85157C1.53299 9.11679 2.11679 8.53299 2.85156 8.22852C3.20263 8.0831 3.54159 8.03707 3.82715 8.01758C4.08818 7.99977 4.39501 7.99997 4.70996 8H5.29004L5.75195 8.00196ZM4.75 9.5C4.13845 9.5 3.79431 9.49968 3.5332 9.57618C3.49591 9.5871 3.46023 9.59999 3.42578 9.61426C3.10427 9.74749 2.84061 9.98786 2.67773 10.292C2.65452 10.3354 2.63325 10.38 2.61426 10.4258C2.53126 10.6262 2.50814 10.8657 2.50195 11.25C2.49963 11.394 2.5 11.5588 2.5 11.749V12.251C2.5 12.4412 2.49963 12.606 2.50195 12.75C2.50814 13.1343 2.53126 13.3738 2.61426 13.5742C2.76649 13.9416 3.05839 14.2335 3.42578 14.3857C3.46023 14.4 3.49592 14.4129 3.5332 14.4238C3.79431 14.5003 4.13845 14.5 4.75 14.5H5.25C5.94891 14.5 6.29856 14.4999 6.57422 14.3857C6.9416 14.2335 7.23351 13.9416 7.38574 13.5742C7.46874 13.3738 7.49186 13.1343 7.49805 12.75C7.50037 12.6057 7.5 12.4409 7.5 12.25V11.75C7.5 11.5592 7.50037 11.3943 7.49805 11.25C7.49263 10.9138 7.47409 10.6882 7.41406 10.5029C7.40551 10.4765 7.39608 10.4508 7.38574 10.4258C7.25252 10.1043 7.01214 9.84061 6.70801 9.67774C6.66465 9.65452 6.62005 9.63325 6.57422 9.61426C6.38037 9.53397 6.14982 9.51001 5.78711 9.50293L5.37695 9.5H4.75ZM11.752 0.00195683C11.9005 0.00417449 12.0424 0.00868269 12.1729 0.0175818C12.4584 0.0370653 12.7974 0.0831038 13.1484 0.228519C13.8832 0.532991 14.467 1.11679 14.7715 1.85157C14.9169 2.20263 14.9629 2.5416 14.9824 2.82715C14.9914 2.95815 14.9958 3.1007 14.998 3.25H16V4.75H14.998C14.9958 4.89931 14.9914 5.04185 14.9824 5.17286C14.9629 5.45841 14.9169 5.79738 14.7715 6.14844C14.467 6.88322 13.8832 7.46702 13.1484 7.77149C12.7974 7.9169 12.4584 7.96294 12.1729 7.98243C11.9118 8.00024 11.605 8.00004 11.29 8H10.71C10.395 8.00004 10.0882 8.00024 9.82715 7.98243C9.54159 7.96294 9.20262 7.9169 8.85156 7.77149C8.11679 7.46701 7.53299 6.88322 7.22852 6.14844C7.0831 5.79738 7.03706 5.45841 7.01758 5.17286L7.00195 4.75H0V3.25H7.00195C7.00416 3.1007 7.00864 2.95815 7.01758 2.82715C7.03706 2.54159 7.0831 2.20263 7.22852 1.85157C7.53299 1.11679 8.11679 0.532993 8.85156 0.228519C9.20262 0.0831048 9.54159 0.0370655 9.82715 0.0175818C10.0882 -0.000228366 10.395 -2.76315e-05 10.71 3.70663e-06H11.29L11.752 0.00195683ZM10.75 1.5C10.0511 1.5 9.70144 1.50008 9.42578 1.61426C9.0584 1.7665 8.76649 2.0584 8.61426 2.42578C8.53126 2.62617 8.50814 2.86574 8.50195 3.25C8.49963 3.39435 8.5 3.55915 8.5 3.75V4.25C8.5 4.44085 8.49963 4.60566 8.50195 4.75C8.50737 5.08624 8.52591 5.31176 8.58594 5.49707C8.59449 5.52346 8.60391 5.54925 8.61426 5.57422C8.74748 5.89574 8.98785 6.15939 9.29199 6.32227C9.33535 6.34548 9.37995 6.36675 9.42578 6.38575C9.68421 6.49279 10.0078 6.49959 10.623 6.5H11.25C11.8615 6.5 12.2057 6.50032 12.4668 6.42383C12.5041 6.41291 12.5398 6.40001 12.5742 6.38575C12.8957 6.25252 13.1594 6.01215 13.3223 5.70801C13.3455 5.66465 13.3668 5.62005 13.3857 5.57422C13.4687 5.37384 13.4919 5.13427 13.498 4.75C13.5004 4.60601 13.5 4.44123 13.5 4.25098V3.74903C13.5 3.55877 13.5004 3.394 13.498 3.25C13.4919 2.86574 13.4687 2.62617 13.3857 2.42578C13.2335 2.0584 12.9416 1.7665 12.5742 1.61426C12.5398 1.59999 12.5041 1.5871 12.4668 1.57618C12.2709 1.51879 12.0283 1.50456 11.6611 1.50098L11.25 1.5H10.75Z" fill="white"/>
        </svg>
      </button>
    </div>

    <!-- Node ID Inspector Section -->
    <div id="node-id-section" class="node-id-section">
      <div class="unified-text-small unified-text-muted unified-mb-16" style="line-height: 1.5;">
        Получение и сравнение Node ID выделенных элементов
      </div>

      <div class="unified-button-group unified-mb-8">
        <button id="get-node-id-button" class="unified-button unified-button-secondary" style="flex: 1;">
          Получить ID выделенного
        </button>
        <button id="compare-ids-button" class="unified-button unified-button-secondary" style="flex: 1;">
          Сравнить ID
        </button>
      </div>

      <div id="current-node-id" class="unified-text-small unified-text-muted unified-mb-8">ID: не выбран</div>
      
      <textarea id="node-ids-textarea" class="unified-textarea" placeholder="Здесь будут сохраняться ID выделенных объектов...&#10;Каждый ID на новой строке" rows="4"></textarea>
      
      <div id="comparison-result" class="comparison-result" style="display: none;"></div>
    </div>

    <!-- AI Design Lint Section -->
    <div id="ai-design-lint-section" class="ai-design-lint-section">
      
      <!-- Основной экран -->
      <div id="ai-main-screen">
        

        
        <!-- Заголовок с кнопкой настроек -->

        <div class="unified-text-small unified-text-muted unified-mb-16" style="line-height: 1.5;">
          Технический аудит компонентов с помощью AI: проверка токенов, доступности, готовности к коду
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <button id="ai-settings-button" class="unified-icon-button" style="padding: 4px;">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 12.5C11.3807 12.5 12.5 11.3807 12.5 10C12.5 8.61929 11.3807 7.5 10 7.5C8.61929 7.5 7.5 8.61929 7.5 10C7.5 11.3807 8.61929 12.5 10 12.5Z" stroke="#AAAAAA" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M16.1667 12.5C16.0551 12.7513 16.0223 13.0301 16.0722 13.3006C16.122 13.5711 16.2521 13.8203 16.4458 14.0167L16.4917 14.0625C16.6466 14.2172 16.7694 14.4013 16.8533 14.6041C16.9372 14.8069 16.9806 15.0244 16.9806 15.2438C16.9806 15.4631 16.9372 15.6806 16.8533 15.8834C16.7694 16.0862 16.6466 16.2703 16.4917 16.425C16.337 16.5799 16.1528 16.7027 15.95 16.7866C15.7473 16.8705 15.5297 16.9139 15.3104 16.9139C15.0911 16.9139 14.8735 16.8705 14.6708 16.7866C14.468 16.7027 14.2838 16.5799 14.1292 16.425L14.0833 16.3792C13.887 16.1854 13.6378 16.0553 13.3673 16.0055C13.0968 15.9556 12.818 15.9884 12.5667 16.1C12.3203 16.2059 12.1103 16.3828 11.9631 16.6088C11.816 16.8348 11.738 17.0998 11.7375 17.3708V17.5C11.7375 17.942 11.5619 18.366 11.2494 18.6785C10.9368 18.9911 10.5128 19.1667 10.0708 19.1667C9.62886 19.1667 9.20484 18.9911 8.8923 18.6785C8.57976 18.366 8.40417 17.942 8.40417 17.5V17.4292C8.39771 17.1477 8.30996 16.8744 8.15178 16.6429C7.99359 16.4114 7.77203 16.2317 7.5125 16.125C7.26122 16.0134 6.98244 15.9806 6.71191 16.0305C6.44138 16.0803 6.19218 16.2104 5.99583 16.4042L5.95 16.45C5.79535 16.6049 5.61121 16.7277 5.40844 16.8116C5.20567 16.8955 4.98813 16.9389 4.76875 16.9389C4.54937 16.9389 4.33183 16.8955 4.12906 16.8116C3.92629 16.7277 3.74215 16.6049 3.5875 16.45C3.43261 16.2953 3.30983 16.1112 3.22593 15.9084C3.14203 15.7056 3.09861 15.4881 3.09861 15.2688C3.09861 15.0494 3.14203 14.8319 3.22593 14.6291C3.30983 14.4263 3.43261 14.2422 3.5875 14.0875L3.63333 14.0417C3.82713 13.8453 3.95723 13.5961 4.00707 13.3256C4.0569 13.0551 4.02413 12.7763 3.91833 12.525C3.81245 12.2786 3.63552 12.0686 3.40953 11.9215C3.18354 11.7743 2.91856 11.6963 2.6475 11.6958H2.5C2.05797 11.6958 1.63405 11.5202 1.32149 11.2077C1.00893 10.8951 0.833332 10.4711 0.833332 10.0292C0.833332 9.58721 1.00893 9.16319 1.32149 8.85065C1.63405 8.53811 2.05797 8.36252 2.5 8.36252H2.57083C2.85235 8.35606 3.12563 8.26831 3.35713 8.11012C3.58863 7.95194 3.76831 7.73038 3.875 7.47085C3.98663 7.21957 4.0194 6.94079 3.96957 6.67026C3.91974 6.39973 3.78964 6.15053 3.59583 5.95418L3.55 5.90835C3.39511 5.7537 3.27233 5.56956 3.18843 5.36679C3.10453 5.16402 3.06111 4.94648 3.06111 4.7271C3.06111 4.50772 3.10453 4.29018 3.18843 4.08741C3.27233 3.88464 3.39511 3.7005 3.55 3.54585C3.70465 3.39096 3.88879 3.26818 4.09156 3.18428C4.29433 3.10038 4.51187 3.05696 4.73125 3.05696C4.95063 3.05696 5.16817 3.10038 5.37094 3.18428C5.57371 3.26818 5.75785 3.39096 5.9125 3.54585L5.95833 3.59168C6.15468 3.78548 6.40388 3.91558 6.67441 3.96542C6.94494 4.01525 7.22372 3.98248 7.475 3.87668H7.5C7.74638 3.7708 7.95641 3.59387 8.10356 3.36788C8.25071 3.14189 8.32871 2.87691 8.32917 2.60585V2.50002C8.32917 2.05799 8.50476 1.63407 8.8173 1.32151C9.12984 1.00895 9.55377 0.833353 9.99583 0.833353C10.4379 0.833353 10.8618 1.00895 11.1744 1.32151C11.4869 1.63407 11.6625 2.05799 11.6625 2.50002V2.57085C11.663 2.84191 11.741 3.10689 11.8881 3.33288C12.0353 3.55887 12.2453 3.7358 12.4917 3.84168C12.7429 3.95331 13.0217 3.98608 13.2923 3.93625C13.5628 3.88642 13.812 3.75632 14.0083 3.56252L14.0542 3.51668C14.2088 3.3618 14.393 3.23902 14.5958 3.15512C14.7985 3.07121 15.0161 3.02779 15.2354 3.02779C15.4548 3.02779 15.6724 3.07121 15.8751 3.15512C16.0779 3.23902 16.262 3.3618 16.4167 3.51668C16.5716 3.67133 16.6943 3.85547 16.7782 4.05824C16.8621 4.26101 16.9056 4.47855 16.9056 4.69793C16.9056 4.91731 16.8621 5.13485 16.7782 5.33762C16.6943 5.54039 16.5716 5.72453 16.4167 5.87918L16.3708 5.92502C16.177 6.12137 16.0469 6.37057 15.9971 6.6411C15.9473 6.91163 15.98 7.19041 16.0858 7.44168V7.50002C16.1917 7.7464 16.3686 7.95643 16.5946 8.10358C16.8206 8.25073 17.0856 8.32873 17.3567 8.32918H17.5C17.942 8.32918 18.366 8.50478 18.6786 8.81732C18.9911 9.12986 19.1667 9.55378 19.1667 9.99585C19.1667 10.4379 18.9911 10.8618 18.6786 11.1744C18.366 11.4869 17.942 11.6625 17.5 11.6625H17.4292C17.1581 11.663 16.8931 11.741 16.6671 11.8881C16.4411 12.0353 16.2642 12.2453 16.1583 12.4917V12.5Z" stroke="#AAAAAA" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

       


        <!-- Кнопка анализа -->
        <button id="analyze-design-button" class="unified-button unified-button-primary">Анализировать дизайн</button>

        <!-- Результаты анализа -->
        <div id="ai-analysis-result" class="ai-analysis-result" style="display: none;"></div>

        <!-- Новые компоненты для локального анализа -->
        <div id="component-analysis-panel" style="display: none;">
          <!-- Панель оценки -->
          <div id="score-panel" class="analysis-score-panel">
            <div class="score-display">
              <div>
                <div id="score-number" class="score-number">0</div>
                <div class="score-label">Component Score</div>
              </div>
              <div class="score-breakdown">
                <div class="score-item">
                  <span class="score-item-label">Layers</span>
                  <span id="layers-count" class="score-item-value">0</span>
                </div>
                <div class="score-item">
                  <span class="score-item-label">Tokens</span>
                  <span id="tokens-count" class="score-item-value">0</span>
                </div>
                <div class="score-item">
                  <span class="score-item-label">Hardcoded</span>
                  <span id="hardcoded-count" class="score-item-value">0</span>
                </div>
                <div class="score-item">
                  <span class="score-item-label">Issues</span>
                  <span id="issues-count" class="score-item-value">0</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Секция токенов -->
          <div id="tokens-section" class="analysis-section">
            <div class="analysis-section-header">
              <div class="analysis-section-title">Token Usage</div>
              <button class="analysis-section-toggle" onclick="toggleSection('tokens-content')">▼</button>
            </div>
            <div id="tokens-content" class="analysis-section-content" style="display: block;">
              <div id="tokens-list"></div>
            </div>
          </div>

          <!-- Секция hardcoded значений -->
          <div id="hardcoded-section" class="analysis-section">
            <div class="analysis-section-header">
              <div class="analysis-section-title">Hard-coded Values</div>
              <button class="analysis-section-toggle" onclick="toggleSection('hardcoded-content')">▼</button>
            </div>
            <div id="hardcoded-content" class="analysis-section-content" style="display: block;">
              <div id="hardcoded-list"></div>
            </div>
          </div>

          <!-- Секция рекомендаций -->
          <div id="recommendations-section" class="analysis-section">
            <div class="analysis-section-header">
              <div class="analysis-section-title">Recommendations</div>
              <button class="analysis-section-toggle" onclick="toggleSection('recommendations-content')">▼</button>
            </div>
            <div id="recommendations-content" class="analysis-section-content" style="display: block;">
              <div id="recommendations-list"></div>
            </div>
          </div>

          <!-- Секция предложений токенов -->
          <div id="token-suggestions-section" class="analysis-section">
            <div class="analysis-section-header">
              <div class="analysis-section-title">Token Suggestions</div>
              <button class="analysis-section-toggle" onclick="toggleSection('token-suggestions-content')">▼</button>
            </div>
            <div id="token-suggestions-content" class="analysis-section-content" style="display: block;">
              <div id="token-suggestions-list"></div>
            </div>
          </div>

          <!-- Кнопки экспорта -->
          <div class="unified-button-group unified-mt-16">
            <button id="export-json-button" class="unified-button unified-button-secondary" style="flex: 1;">
              Export JSON
            </button>
            <button id="export-markdown-button" class="unified-button unified-button-secondary" style="flex: 1;">
              Export Markdown
            </button>
          </div>

          <!-- AI Chat Panel -->
          <div id="ai-chat-panel" class="analysis-section" style="margin-top: 16px;">
            <div class="analysis-section-header">
              <div class="analysis-section-title">AI Assistant</div>
              <button class="analysis-section-toggle" onclick="toggleSection('ai-chat-content')">▼</button>
            </div>
            <div id="ai-chat-content" class="analysis-section-content" style="display: block;">
              <!-- История чата -->
              <div id="ai-chat-history" style="max-height: 150px; overflow-y: auto; margin-bottom: 8px; padding: 6px; background: #2A2A32; border-radius: 6px; border: 1px solid #505059;">
                <div style="color: #AAAAAA; font-size: 11px; text-align: center; padding: 12px;">
                  Задайте вопрос о компоненте
                </div>
              </div>
              
              <!-- Поле ввода -->
              <div style="display: flex; flex-direction: column; gap: 8px;">
                <textarea id="ai-chat-input" class="unified-textarea" placeholder="Как исправить проблему с отступами?" style="min-height: 60px; max-height: 120px;"></textarea>
                <button id="ai-chat-send-button" class="unified-button unified-button-primary">
                  Задать вопрос AI
                </button>
              </div>
              
              <!-- Информация о токенах -->
              <div id="ai-chat-tokens-info" style="font-size: 9px; color: #AAAAAA; text-align: center; margin-top: 4px; display: none;">
                <span id="ai-chat-tokens-count">0</span> сообщений
              </div>
            </div>
          </div>
        </div>

        <!-- Диалоговый режим -->
        <div id="ai-chat-section" style="display: none; margin-top: 16px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label class="unified-label" style="margin-bottom: 0;">Задать уточняющий вопрос:</label>
            <button id="ai-clear-history-button" class="unified-button unified-button-tertiary" style="padding: 4px 8px; font-size: 11px;">
              Очистить историю
            </button>
          </div>
          
          <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <textarea id="ai-follow-up-input" class="unified-textarea" placeholder="Например: Как исправить проблему с отступами? Какой токен использовать для цвета?" style="min-height: 44px;"></textarea>
          </div>
          
          <button id="ai-ask-question-button" class="unified-button unified-button-secondary" style="width: 100%; margin-bottom: 8px;">
            Задать вопрос
          </button>
          
          <div id="ai-chat-tokens-info" style="font-size: 10px; color: #AAAAAA; text-align: center; display: none;">
            История: <span id="ai-tokens-count">0</span> сообщений
          </div>
        </div>
      </div>

      <!-- Экран настроек -->
      <div id="ai-settings-screen" style="display: none;">
        <!-- Заголовок настроек -->
        <div style="display: flex; align-items: center; margin-bottom: 16px;">
          <button id="ai-settings-back-button" class="back-button" style="background: transparent; border: none; cursor: pointer; padding: 4px; margin-right: 8px; display: flex; align-items: center;">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12.5 15L7.5 10L12.5 5" stroke="#AAAAAA" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <h3 style="font-size: 14px; font-weight: 600; margin: 0; color: #F86025;">Настройки AI Design Lint</h3>
        </div>

        <!-- Блок информации -->
        <div style="background: #2A2A32; border-radius: 8px; padding: 12px; margin-bottom: 16px; font-size: 11px; line-height: 1.5; color: #AAAAAA;">
          <div style="font-weight: 600; color: #FFFFFF; margin-bottom: 8px;">Что проверяется:</div>
        • Hard-coded значения vs токены<br>
        • Несоответствия отступов (7px вместо 8px)<br>
        • Контраст цветов (WCAG)<br>
        • Touch targets (44x44px минимум)<br>
        • Структура компонента<br>
        • Готовность к коду (0-100%)
      </div>
      
        <!-- Токен -->
      <div class="ai-token-input" style="margin-bottom: 16px;">
        <label for="yandex-token" class="unified-label">Yandex OAuth Token:</label>
        <input type="password" id="yandex-token" class="unified-input" placeholder="Введите ваш OAuth токен" style="font-family: 'SF Mono', 'Monaco', monospace;">
          <div class="unified-text-small unified-text-muted" style="margin-top: 4px;">
            Токен будет сохранен локально. <a href="https://oauth.yandex.ru/authorize?response_type=token&client_id=YOUR_CLIENT_ID" target="_blank" class="unified-link">Получить токен</a>
          </div>
      </div>

        <!-- JSON дизайн-системы -->
        <div style="margin-bottom: 16px;">
          <label class="unified-label">JSON дизайн-системы (опционально):</label>
          
          <!-- Кнопка загрузки файла -->
          <div class="unified-button-group" style="margin-bottom: 8px;">
            <button id="ai-load-json-button" class="unified-button unified-button-secondary" style="flex: 1;">
              Загрузить JSON
            </button>
            <button id="ai-clear-json-button" class="unified-button unified-button-secondary" style="flex: 1;" disabled>
              Очистить
            </button>
      </div>
          <input type="file" id="ai-json-file-input" accept=".json" style="display: none;">
          
          <!-- Статус загруженного JSON -->
          <div id="ai-json-status" style="font-size: 11px; color: #AAAAAA; padding: 8px; background: #2A2A32; border-radius: 6px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <span id="ai-json-status-text">Файл не загружен</span>
              <button id="ai-view-json-button" style="background: transparent; border: none; color: #F86025; cursor: pointer; font-size: 11px; padding: 0;">Просмотр</button>
            </div>
          </div>
          
          <div style="font-size: 11px; color: #AAAAAA; margin-top: 4px;">
            Загрузите JSON с токенами, правилами и компонентами вашей дизайн-системы для более точного анализа
          </div>
        </div>

        <!-- Модальное окно для просмотра JSON -->
        <div id="ai-json-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; padding: 20px;">
          <div style="background: #2A2A32; border-radius: 12px; max-width: 500px; margin: 0 auto; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
            <div style="padding: 16px; border-bottom: 1px solid #505059; display: flex; justify-content: space-between; align-items: center;">
              <h4 style="margin: 0; color: #FFFFFF; font-size: 14px;">Просмотр JSON дизайн-системы</h4>
              <button id="ai-close-json-modal" style="background: transparent; border: none; color: #AAAAAA; cursor: pointer; font-size: 20px; padding: 0; line-height: 1;">&times;</button>
            </div>
            <div style="padding: 16px; overflow-y: auto; flex: 1;">
              <pre id="ai-json-preview" style="margin: 0; color: #FFFFFF; font-size: 11px; font-family: 'SF Mono', Monaco, monospace; white-space: pre-wrap; word-wrap: break-word;"></pre>
            </div>
          </div>
        </div>

        <!-- Кнопка сохранения -->
        <button id="ai-save-settings-button" class="unified-button unified-button-secondary" style="width: 100%;">Сохранить настройки</button>
      </div>

    </div>

    <!-- Design System Validator Section -->
    <div id="design-system-validator-section" class="design-system-validator-section">
      
      <!-- Главные кнопки -->
      <div style="display: flex; gap: 8px; margin-bottom: 16px; align-items: center;">
        <button id="dsv-validate-button-main" class="unified-button unified-button-primary" style="flex-grow: 1;">
          Проверить
        </button>
        <button id="dsv-settings-button" class="settings-button" title="Настройки валидатора">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5.75195 8.00196C5.90055 8.00417 6.04242 8.00868 6.17285 8.01758C6.45841 8.03707 6.79738 8.0831 7.14844 8.22852C7.88321 8.53299 8.46701 9.11679 8.77148 9.85157C8.9169 10.2026 8.96294 10.5416 8.98242 10.8272C8.99136 10.9582 8.99584 11.1007 8.99805 11.25H16V12.75H8.99805C8.99584 12.8993 8.99136 13.0419 8.98242 13.1729C8.96294 13.4584 8.9169 13.7974 8.77148 14.1484C8.46701 14.8832 7.88321 15.467 7.14844 15.7715C6.79738 15.9169 6.45841 15.9629 6.17285 15.9824C5.91182 16.0002 5.60499 16 5.29004 16H4.70996C4.39501 16 4.08818 16.0002 3.82715 15.9824C3.54159 15.9629 3.20263 15.9169 2.85156 15.7715C2.11679 15.467 1.53299 14.8832 1.22852 14.1484C1.0831 13.7974 1.03706 13.4584 1.01758 13.1729L1.00195 12.75H0V11.25H1.00195C1.00416 11.1007 1.00864 10.9582 1.01758 10.8272C1.03706 10.5416 1.0831 10.2026 1.22852 9.85157C1.53299 9.11679 2.11679 8.53299 2.85156 8.22852C3.20263 8.0831 3.54159 8.03707 3.82715 8.01758C4.08818 7.99977 4.39501 7.99997 4.70996 8H5.29004L5.75195 8.00196ZM4.75 9.5C4.13845 9.5 3.79431 9.49968 3.5332 9.57618C3.49591 9.5871 3.46023 9.59999 3.42578 9.61426C3.10427 9.74749 2.84061 9.98786 2.67773 10.292C2.65452 10.3354 2.63325 10.38 2.61426 10.4258C2.53126 10.6262 2.50814 10.8657 2.50195 11.25C2.49963 11.394 2.5 11.5588 2.5 11.749V12.251C2.5 12.4412 2.49963 12.606 2.50195 12.75C2.50814 13.1343 2.53126 13.3738 2.61426 13.5742C2.76649 13.9416 3.05839 14.2335 3.42578 14.3857C3.46023 14.4 3.49592 14.4129 3.5332 14.4238C3.79431 14.5003 4.13845 14.5 4.75 14.5H5.25C5.94891 14.5 6.29856 14.4999 6.57422 14.3857C6.9416 14.2335 7.23351 13.9416 7.38574 13.5742C7.46874 13.3738 7.49186 13.1343 7.49805 12.75C7.50037 12.6057 7.5 12.4409 7.5 12.25V11.75C7.5 11.5592 7.50037 11.3943 7.49805 11.25C7.49263 10.9138 7.47409 10.6882 7.41406 10.5029C7.40551 10.4765 7.39608 10.4508 7.38574 10.4258C7.25252 10.1043 7.01214 9.84061 6.70801 9.67774C6.66465 9.65452 6.62005 9.63325 6.57422 9.61426C6.38037 9.53397 6.14982 9.51001 5.78711 9.50293L5.37695 9.5H4.75ZM11.752 0.00195683C11.9005 0.00417449 12.0424 0.00868269 12.1729 0.0175818C12.4584 0.0370653 12.7974 0.0831038 13.1484 0.228519C13.8832 0.532991 14.467 1.11679 14.7715 1.85157C14.9169 2.20263 14.9629 2.5416 14.9824 2.82715C14.9914 2.95815 14.9958 3.1007 14.998 3.25H16V4.75H14.998C14.9958 4.89931 14.9914 5.04185 14.9824 5.17286C14.9629 5.45841 14.9169 5.79738 14.7715 6.14844C14.467 6.88322 13.8832 7.46702 13.1484 7.77149C12.7974 7.9169 12.4584 7.96294 12.1729 7.98243C11.9118 8.00024 11.605 8.00004 11.29 8H10.71C10.395 8.00004 10.0882 8.00024 9.82715 7.98243C9.54159 7.96294 9.20262 7.9169 8.85156 7.77149C8.11679 7.46701 7.53299 6.88322 7.22852 6.14844C7.0831 5.79738 7.03706 5.45841 7.01758 5.17286L7.00195 4.75H0V3.25H7.00195C7.00416 3.1007 7.00864 2.95815 7.01758 2.82715C7.03706 2.54159 7.0831 2.20263 7.22852 1.85157C7.53299 1.11679 8.11679 0.532993 8.85156 0.228519C9.20262 0.0831048 9.54159 0.0370655 9.82715 0.0175818C10.0882 -0.000228366 10.395 -2.76315e-05 10.71 3.70663e-06H11.29L11.752 0.00195683ZM10.75 1.5C10.0511 1.5 9.70144 1.50008 9.42578 1.61426C9.0584 1.7665 8.76649 2.0584 8.61426 2.42578C8.53126 2.62617 8.50814 2.86574 8.50195 3.25C8.49963 3.39435 8.5 3.55915 8.5 3.75V4.25C8.5 4.44085 8.49963 4.60566 8.50195 4.75C8.50737 5.08624 8.52591 5.31176 8.58594 5.49707C8.59449 5.52346 8.60391 5.54925 8.61426 5.57422C8.74748 5.89574 8.98785 6.15939 9.29199 6.32227C9.33535 6.34548 9.37995 6.36675 9.42578 6.38575C9.68421 6.49279 10.0078 6.49959 10.623 6.5H11.25C11.8615 6.5 12.2057 6.50032 12.4668 6.42383C12.5041 6.41291 12.5398 6.40001 12.5742 6.38575C12.8957 6.25252 13.1594 6.01215 13.3223 5.70801C13.3455 5.66465 13.3668 5.62005 13.3857 5.57422C13.4687 5.37384 13.4919 5.13427 13.498 4.75C13.5004 4.60601 13.5 4.44123 13.5 4.25098V3.74903C13.5 3.55877 13.5004 3.394 13.498 3.25C13.4919 2.86574 13.4687 2.62617 13.3857 2.42578C13.2335 2.0584 12.9416 1.7665 12.5742 1.61426C12.5398 1.59999 12.5041 1.5871 12.4668 1.57618C12.2709 1.51879 12.0283 1.50456 11.6611 1.50098L11.25 1.5H10.75Z" fill="white"/>
          </svg>
        </button>
      </div>

      <!-- Панель настроек (скрыта по умолчанию) -->
      <div id="dsv-settings-panel" style="display: none; margin-bottom: 16px;">
      
      <!-- Управление токенами -->
      <div style="margin-bottom: 16px; padding: 16px; background: #2A2A32; border-radius: 8px; border: 1px solid #505059;">
        <div style="font-size: 12px; color: #FFFFFF; font-weight: 600; margin-bottom: 12px;">
          📦 Управление токенами
      </div>

        <!-- Статус токенов -->
        <div style="margin-bottom: 12px; padding: 10px; background: #1E1E26; border-radius: 6px;">
          <div id="dsv-tokens-status-text" style="font-size: 11px; color: #AAAAAA;">Токены не загружены</div>
        </div>

        <!-- Кнопки управления -->
        <div style="margin-bottom: 12px;">
          <button id="dsv-import-tokens-button" class="unified-button unified-button-secondary" style="width: 100%; font-size: 11px; padding: 8px 12px;">
            📥 Импорт токенов из файла
              </button>
      </div>

        <!-- Textarea с JSON токенов -->
        <details style="margin-top: 12px;">
          <summary style="font-size: 11px; color: #FFFFFF; cursor: pointer; list-style: none; display: flex; align-items: center; gap: 8px;">
            <span style="color: #F86025;">▸</span> Просмотр JSON токенов
          </summary>
          <div style="margin-top: 12px;">
            <textarea id="dsv-tokens-json-textarea" 
                      readonly
                      style="width: 100%; min-height: 200px; max-height: 400px; 
                             padding: 12px; background: #1E1E26; border: 1px solid #505059; 
                             border-radius: 6px; color: #FFFFFF; font-size: 10px; 
                             font-family: 'SF Mono', Monaco, monospace; resize: vertical;"
                      placeholder="JSON токенов будет здесь после импорта..."></textarea>
            <button id="dsv-copy-json-button" class="unified-button unified-button-tertiary" style="width: 100%; margin-top: 8px; font-size: 11px; display: none;">
              📋 Копировать JSON
              </button>
              </div>
        </details>

        <div style="font-size: 10px; color: #AAAAAA; margin-top: 12px; line-height: 1.4;">
          <strong style="color: #FFFFFF;">Как использовать:</strong><br>
          1. Откройте файл библиотеки с токенами<br>
          2. Нажмите "📥 Импорт" — токены сохранятся в плагин<br>
          3. Токены будут доступны во <strong style="color: #FFFFFF;">всех файлах Figma</strong> для автоисправления<br>
          <br>
          <strong style="color: #F86025;">Альтернативный способ:</strong> Экспортируйте JSON и загрузите в других проектах через "📂 Загрузить JSON файл"
              </div>
              </div>
      
      <!-- Заголовок с описанием -->
      <div class="unified-text-small unified-text-muted unified-mb-16" style="line-height: 1.5;">
        Проверка использования Figma Variables (дизайн-токенов) в компонентах
            </div>

      <!-- Выбор режима проверки -->
      <div class="unified-mb-16">
        <label class="unified-label">Режим проверки:</label>
        <div class="unified-button-group">
          <button id="dsv-mode-local" class="dsv-mode-button unified-button unified-button-secondary" data-mode="local" style="flex: 1;">Local</button>
          <button id="dsv-mode-remote" class="dsv-mode-button unified-button unified-button-secondary" data-mode="remote" style="flex: 1;">Remote</button>
          <button id="dsv-mode-all" class="dsv-mode-button unified-button unified-button-primary" data-mode="all" style="flex: 1;">All</button>
          </div>
      </div>

        <!-- Подсказка для пользователя -->
        <div style="background: #2A2A32; border-radius: 8px; padding: 12px; margin-bottom: 16px; font-size: 11px; line-height: 1.5; color: #AAAAAA; border-left: 3px solid #F86025;">
          <strong style="color: #FFFFFF;">Совет:</strong> Если ничего не выделено — будет проверена вся текущая страница. Выделите объекты для проверки конкретных элементов.
      </div>

      <!-- Настройки проверки -->
      <div style="margin-bottom: 16px;">
        <label style="font-size: 12px; color: #FFFFFF; display: block; margin-bottom: 8px; font-weight: 600;">Настройки:</label>
        
        <!-- Общие настройки -->
        <div style="background: #2A2A32; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #FFFFFF; margin-bottom: 8px;">
            <input type="checkbox" id="dsv-skip-instances" style="margin-right: 8px; cursor: pointer;">
            <span>Пропускать вложенные Instance компоненты</span>
          </label>
          <div style="font-size: 10px; color: #AAAAAA; margin-top: 4px; margin-left: 24px; margin-bottom: 12px;">
            Если включено, Instance внутри компонентов не будут проверяться на использование токенов
          </div>
          
          <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px; color: #FFFFFF;">
            <input type="checkbox" id="dsv-filter-orb-prefix" checked style="margin-right: 8px; cursor: pointer;">
            <span>Проверять только компоненты с префиксом "orb-"</span>
          </label>
          <div style="font-size: 10px; color: #AAAAAA; margin-top: 4px; margin-left: 24px;">
            Если включено, будут проверяться только компоненты нашей дизайн-системы (с префиксом "orb-"), нативные и сторонние компоненты будут пропущены
          </div>
        </div>

        <!-- Настройки проверяемых свойств -->
        <details style="background: #2A2A32; border-radius: 8px; padding: 12px;">
          <summary style="font-size: 12px; color: #FFFFFF; font-weight: 600; cursor: pointer; list-style: none; display: flex; align-items: center; gap: 8px; margin-bottom: 0;">
            <span style="color: #F86025;">▸</span> Проверяемые свойства
          </summary>
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #505059;">
            <div style="font-size: 10px; color: #AAAAAA; margin-bottom: 12px;">
              Выберите какие свойства проверять на наличие токенов:
            </div>
            
            <!-- Цвета -->
            <div style="margin-bottom: 12px;">
              <div style="font-size: 11px; color: #FFFFFF; font-weight: 600; margin-bottom: 6px;">🎨 Цвета</div>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF; margin-bottom: 4px;">
                <input type="checkbox" id="dsv-check-fills" checked style="margin-right: 8px; cursor: pointer;">
                <span>Fill (Заливка)</span>
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF;">
                <input type="checkbox" id="dsv-check-strokes" checked style="margin-right: 8px; cursor: pointer;">
                <span>Stroke (Обводка)</span>
              </label>
            </div>

            <!-- Размеры и отступы -->
            <div style="margin-bottom: 12px;">
              <div style="font-size: 11px; color: #FFFFFF; font-weight: 600; margin-bottom: 6px;">📏 Размеры и отступы</div>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF; margin-bottom: 4px;">
                <input type="checkbox" id="dsv-check-corner-radius" checked style="margin-right: 8px; cursor: pointer;">
                <span>Corner Radius (Радиус скругления)</span>
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF; margin-bottom: 4px;">
                <input type="checkbox" id="dsv-check-spacing" checked style="margin-right: 8px; cursor: pointer;">
                <span>Gap / Item Spacing (Отступы между элементами)</span>
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF;">
                <input type="checkbox" id="dsv-check-padding" checked style="margin-right: 8px; cursor: pointer;">
                <span>Padding (Внутренние отступы)</span>
              </label>
            </div>

            <!-- Эффекты и прочее -->
            <div>
              <div style="font-size: 11px; color: #FFFFFF; font-weight: 600; margin-bottom: 6px;">✨ Эффекты и прочее</div>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF; margin-bottom: 4px;">
                <input type="checkbox" id="dsv-check-effects" style="margin-right: 8px; cursor: pointer;">
                <span>Effects (Эффекты: тени, размытие)</span>
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF; margin-bottom: 4px;">
                <input type="checkbox" id="dsv-check-opacity" style="margin-right: 8px; cursor: pointer;">
                <span>Opacity (Прозрачность)</span>
              </label>
              <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #FFFFFF;">
                <input type="checkbox" id="dsv-check-size" style="margin-right: 8px; cursor: pointer;">
                <span>Width/Height (Ширина/Высота)</span>
              </label>
            </div>

            <!-- Кнопки быстрых действий -->
            <div class="unified-divider"></div>
              <div class="unified-button-group unified-text-small">
                <button id="dsv-select-all-props" class="unified-button unified-button-tertiary" style="flex: 1;">
                  Все
                </button>
                <button id="dsv-select-none-props" class="unified-button unified-button-tertiary" style="flex: 1;">
                  Нет
                </button>
                <button id="dsv-select-default-props" class="unified-button unified-button-tertiary" style="flex: 1;">
                  По умолчанию
              </button>
            </div>
          </div>
        </details>
      </div>

      </div><!-- Конец панели настроек -->

      <!-- Результаты проверки -->
      <div id="dsv-results-panel" style="display: none;">
        
        <!-- Сводка результатов -->
        <div id="dsv-summary" class="unified-card unified-mb-16">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 40px; font-size: 11px;">
            <div style="display: flex; justify-content: space-between;">
              <span class="unified-text-muted">Проверено элементов: <span id="dsv-total-nodes" style="color: #FFFFFF; font-weight: 600;">0</span></span>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span class="unified-text-muted">Найдено проблем: <span id="dsv-total-issues" style="color: #F44336; font-weight: 600;">0</span></span>
            </div>
          </div>
        </div>

        <!-- Список проблем -->
        <div id="dsv-issues-section" style="display: none;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <div class="unified-section-title" style="margin-bottom: 0;">
            ⚠️ Найденные проблемы
            </div>
            <button id="dsv-fix-all-button" class="unified-button unified-button-primary" style="font-size: 11px; padding: 6px 12px; display: none;">
              🔧 Исправить все
            </button>
          </div>
          <div id="dsv-issues-list" class="unified-results-container" style="max-height: 300px; overflow-y: auto;">
            <!-- Issues will be inserted here -->
          </div>
        </div>

        <!-- Кнопка экспорта отчёта удалена по запросу -->
      </div>

      <!-- Индикатор загрузки -->
        <div id="dsv-loading-indicator" class="unified-loading" style="display: none;">
          <div style="margin-bottom: 8px;">Проверка...</div>
        <div id="dsv-progress-text" style="font-size: 11px;">Обработано: <span id="dsv-progress-count">0</span> элементов</div>
      </div>

    </div>

    <!-- Component Properties Export Section -->
    <div id="component-properties-export-section" class="component-properties-export-section">
    
      <p class="unified-text-small unified-text-muted unified-mb-16" style="line-height: 1.5;">
        Соберет все свойства компонентов, их определения и фактическое использование в файле.
      </p>
      
      <div class="unified-button-group unified-mb-16">
        <button id="analyze-component-properties-button" class="unified-button unified-button-secondary" style="flex: 1;">
          Анализировать компоненты
        </button>
        <button id="export-component-properties-button" class="unified-button unified-button-primary" style="flex: 1;">
          Экспортировать свойства
        </button>
      </div>
      
      <div id="component-properties-analysis" class="export-analysis" style="display: none;">
        <div class="analysis-header">
          <h4>Анализ компонентов</h4>
        </div>
        <div class="analysis-content">
          <div id="analysis-stats" class="analysis-stats"></div>
          <div id="analysis-details" class="analysis-details"></div>
        </div>
      </div>
      
      <div id="component-properties-progress" class="export-progress" style="display: none;">
        <div class="export-progress-header">
          <span id="component-properties-progress-text">Подготовка...</span>
          <span id="component-properties-counter" class="export-counter">0/0</span>
        </div>
        
        <div class="export-progress-bar">
          <div id="component-properties-progress-fill" class="export-progress-fill"></div>
        </div>
        
        <div class="export-progress-details">
          <div class="export-progress-info">
            <span id="component-properties-percentage" class="export-percentage">0%</span>
            <span id="component-properties-current-item" class="export-current-item">Обработка...</span>
          </div>
        </div>
      </div>
      
      <div id="component-properties-results" class="export-results" style="display: none;">
        <div class="results-header">
          <h4>Экспорт завершен</h4>
        </div>
        <div class="results-content">
          <p>Файлы готовы к скачиванию:</p>
          <div class="download-buttons">
            <button id="download-json-button" class="secondary-button">Скачать JSON</button>
            <button id="download-csv-button" class="secondary-button">Скачать CSV</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Get Page Text Section -->
    <div id="get-page-text-section" class="get-page-text-section">
      <div class="unified-text-small unified-text-muted unified-mb-16" style="line-height: 1.5;">
        Получить весь текст с текущей страницы Figma. Функция автоматически обходит все видимые элементы и извлекает текстовое содержимое с сохранением структуры слоев.
      </div>
      
      <!-- Настройки экспорта -->
        <details style="background: #2A2A32; border-radius: 8px; padding: 12px; margin-bottom: 12px;">
          <summary style="font-size: 12px; font-weight: 600; color: #FFFFFF; cursor: pointer; user-select: none;">
            Настройки экспорта
        </summary>
        <div style="margin-top: 12px; font-size: 11px;">
          <div style="margin-bottom: 12px;">
            <label class="unified-label" style="font-size: 11px;">Блоки документации (через запятую):</label>
            <input type="text" id="md-doc-blocks" class="unified-input" value="Overview, A11Y" style="font-size: 11px;">
          </div>
          <div style="margin-bottom: 12px;">
            <label class="unified-label" style="font-size: 11px;">Компонент заголовка:</label>
            <input type="text" id="md-heading-component" class="unified-input" value="sourse-heading" style="font-size: 11px;">
          </div>
          <div style="margin-bottom: 12px;">
            <label class="unified-label" style="font-size: 11px;">Компонент текста:</label>
            <input type="text" id="md-text-component" class="unified-input" value="sourse-base" style="font-size: 11px;">
          </div>
          <div style="margin-bottom: 12px;">
            <label class="unified-label" style="font-size: 11px;">Фрейм с изображениями:</label>
            <input type="text" id="md-preview-frame" class="unified-input" value="Preview" style="font-size: 11px;">
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="display: block; color: #AAAAAA; margin-bottom: 8px;">Маппинг размера заголовков:</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px;">
              <div style="display: flex; align-items: center; gap: 4px;">
                <span style="color: #AAAAAA;">lg →</span>
                <input type="number" id="md-size-lg" value="1" min="1" max="6" style="width: 50px; background: #34343C; border: 1px solid #505059; border-radius: 4px; padding: 4px; color: white; font-size: 10px;">
                <span style="color: #888888;">(H1)</span>
              </div>
              <div style="display: flex; align-items: center; gap: 4px;">
                <span style="color: #AAAAAA;">md →</span>
                <input type="number" id="md-size-md" value="2" min="1" max="6" style="width: 50px; background: #34343C; border: 1px solid #505059; border-radius: 4px; padding: 4px; color: white; font-size: 10px;">
                <span style="color: #888888;">(H2)</span>
              </div>
              <div style="display: flex; align-items: center; gap: 4px;">
                <span style="color: #AAAAAA;">sm →</span>
                <input type="number" id="md-size-sm" value="3" min="1" max="6" style="width: 50px; background: #34343C; border: 1px solid #505059; border-radius: 4px; padding: 4px; color: white; font-size: 10px;">
                <span style="color: #888888;">(H3)</span>
              </div>
              <div style="display: flex; align-items: center; gap: 4px;">
                <span style="color: #AAAAAA;">xs →</span>
                <input type="number" id="md-size-xs" value="4" min="1" max="6" style="width: 50px; background: #34343C; border: 1px solid #505059; border-radius: 4px; padding: 4px; color: white; font-size: 10px;">
                <span style="color: #888888;">(H4)</span>
              </div>
            </div>
          </div>
          
          <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <label class="unified-checkbox-container" style="font-size: 11px;">
              <input type="checkbox" id="md-use-indentation" checked>
              Использовать отступы для вложенности
            </label>
          </div>
          <div style="display: flex; gap: 8px; margin-bottom: 12px;">
            <label class="unified-checkbox-container" style="font-size: 11px;">
              <input type="checkbox" id="md-only-doc-blocks" checked>
              Только блоки документации
            </label>
          </div>
          
          <div style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #505059;">
            <label class="unified-label" style="font-size: 11px;">Исключить компоненты (через запятую):</label>
            <input type="text" id="md-excluded-components" class="unified-input" value="sourse-Info" style="font-size: 11px;" placeholder="sourse-Info, другой-компонент">
            <div style="font-size: 10px; color: #888888; margin-top: 4px;">Компоненты и узлы с этими именами будут пропущены при экспорте</div>
          </div>
        </div>
      </details>
      
        <div class="unified-button-group unified-mb-8">
          <button id="get-text-button" class="unified-button unified-button-primary" style="flex: 1;">
            Получить текст со страницы
          </button>
        </div>
        <div class="unified-button-group unified-mb-16">
          <button id="get-page-export-markdown-button" class="unified-button unified-button-primary" style="flex: 1; background: #4CAF50;">
            Экспорт в Markdown + JSON
        </button>
      </div>
      
      <!-- Статистика -->
        <div id="text-stats-section" style="background: #2A2A32; border-radius: 8px; padding: 16px; margin-bottom: 16px; display: none;">
          <div style="font-size: 12px; font-weight: 600; color: #FFFFFF; margin-bottom: 12px;">
            Статистика
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
          <div style="display: flex; justify-content: space-between;">
            <span style="color: #AAAAAA;">Текстовых элементов:</span>
            <span id="text-total-nodes" style="color: #FFFFFF; font-weight: 600;">0</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span style="color: #AAAAAA;">Всего символов:</span>
            <span id="text-total-chars" style="color: #FFFFFF; font-weight: 600;">0</span>
          </div>
        </div>
      </div>
      
      <!-- Область вывода текста -->
      <div id="text-output-container" style="background: #2A2A32; border-radius: 8px; padding: 12px; max-height: 450px; overflow-y: auto; font-size: 11px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; color: #FFFFFF; font-family: 'Courier New', monospace; min-height: 100px; display: none;">
        <!-- Текст будет выведен здесь -->
      </div>
      
        <!-- Кнопки действий -->
        <div id="text-actions-section" class="unified-button-group unified-mt-12" style="display: none;">
          <button id="copy-text-button" class="unified-button unified-button-secondary" style="flex: 1;">Копировать</button>
          <button id="download-text-button" class="unified-button unified-button-secondary" style="flex: 1;">Скачать</button>
        </div>
        
        <!-- Индикатор загрузки -->
        <div id="text-loading-indicator" style="display: none; text-align: center; padding: 20px; color: #AAAAAA; font-size: 12px;">
          Загрузка текста со страницы...
        </div>
        
        <!-- Индикатор экспорта Markdown -->
        <div id="markdown-export-progress" style="display: none; background: #2A2A32; border-radius: 8px; padding: 16px; margin-top: 16px;">
          <div style="text-align: center; color: #AAAAAA; font-size: 12px; margin-bottom: 8px;" id="markdown-progress-text">Экспорт в Markdown...</div>
        <div style="background: #1A1A1A; border-radius: 4px; height: 4px; overflow: hidden;">
          <div id="markdown-progress-bar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
        </div>
      </div>
    </div>

    <!-- SVG Export Section -->
    <div id="svg-export-section" class="svg-export-section">

      <div class="unified-button-group">
        <button id="scan-icons-button" class="unified-button unified-button-primary">
          Посчитать иконки
        </button>
      </div>
      
      <div id="export-stats" class="export-stats" style="display: none;">
        <div class="stats-item">
          <span class="stats-label">Иконок оригинальных</span>
          <span id="component-sets-count" class="stats-value">0</span>
        </div>
        <div class="stats-item">
          <span class="stats-label">Иконок с разными размерами</span>
          <span id="total-variants-count" class="stats-value">0</span>
        </div>
      </div>

      

      

     

      
    </div>

    <div id="svg-export-section" class="svg-export-section">
      <div id="color-options" class="color-options" style="display: none; margin-bottom: 16px;">
        <div class="unified-checkbox-container">
          <input type="checkbox" id="apply-fill-color" />
          <label for="apply-fill-color">Задать цвет иконкам [fill]</label>
        </div>
        
        <div id="color-selection" style="display: none; margin-top: 16px;">
          <div class="color-preset-buttons">
            <button type="button" class="color-preset-btn" data-color="#000000" style="background: #000000; color: white;">Черный</button>
            <button type="button" class="color-preset-btn" data-color="#FFFFFF" style="background: #FFFFFF; color: black; border: 1px solid #666;">Белый</button>
            <button type="button" class="color-preset-btn" data-color="#F86025" style="background: #F86025; color: white;">Orbita</button>
          </div>
          
          <div class="custom-color-input" style="margin-top: 0px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
              <input type="color" id="custom-fill-color" value="#000000" style="width: 32px; height: 32px; border: none; border-radius: 8px; cursor: pointer;">
              <input type="text" id="custom-fill-hex" class="unified-input" value="#000000" placeholder="#000000" style="width: 120px;">
            </div>
          </div>
        </div>
      </div>

      <div class="unified-button-group">
        <button id="export-icons-button" class="unified-button unified-button-primary" style="display: none;">
          Экспортировать в SVG (zip)
        </button>
      </div>

      <!-- Детальный прогрессбар для SVG экспорта -->
      <div id="svg-export-progress" class="svg-export-progress" style="display: none;">
        <div class="export-progress-header">
          <span id="export-progress-text">Подготовка к экспорту...</span>
          <span id="export-counter" class="export-counter">0/0</span>
        </div>
        
        <div class="export-progress-bar">
          <div id="export-progress-fill" class="export-progress-fill"></div>
        </div>
        
        <div class="export-progress-details">
          <div class="progress-info-row">
            <span id="export-percentage" class="export-percentage">0%</span>
            <span id="export-speed" class="export-speed">0 иконок/сек</span>
          </div>
          <div class="progress-info-row">
            <span id="export-current-icon" class="export-current-icon">Готовимся...</span>
          </div>
          <div class="progress-info-row">
            <span id="export-time-info" class="export-time-info">
              <span id="export-elapsed-time">Время: 0с</span>
              <span id="export-remaining-time">Осталось: ~0с</span>
            </span>
          </div>
        </div>
      </div>
    </div>
    
    <div id="settings-dropdown" class="settings-dropdown" style="display: none;">
      <!-- Пункт "Все проверки" -->
      <div class="settings-item all-checks-item">
        <input type="checkbox" id="all-checks" checked>
        <label for="all-checks">Всё проверять</label>
      </div>
      
      <!-- Разделитель -->
      <div class="settings-divider"></div>
      
      <!-- Независимые проверки -->
      <div class="settings-item">
        <input type="checkbox" id="naming-check" checked>
        <label for="naming-check">Название компонента</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет, что имя компонента начинается с "orb-icon-", содержит название иконки и использует только допустимые символы (строчные буквы, цифры и дефисы).</div>
        </div>
      </div>
      
      <!-- Проверка вариантов и зависимая от нее проверка description -->
      <div class="settings-item">
        <input type="checkbox" id="variants-check" checked>
        <label for="variants-check">Варианты компонента</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет наличие и правильность свойств Variant (outline/solid) и Size (lg/md/sm/xs/xxs).</div>
        </div>
      </div>
      <div class="settings-item dependent-item">
        <input type="checkbox" id="description-check" checked>
        <label for="description-check">Описание вариантов</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет, что description компонента соответствует формату "name-variant-size". Зависит от проверки вариантов, так как использует значения Variant и Size.</div>
        </div>
      </div>
      
      <div class="settings-item">
        <input type="checkbox" id="sizes-check" checked>
        <label for="sizes-check">Размеры иконки</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет, что размеры компонента соответствуют требованиям (32x32, 24x24, 16x16, 12x12 или 8x8 px).</div>
        </div>
      </div>
      
      <!-- Проверка структуры и зависимые от нее проверки -->
      <div class="settings-item">
        <input type="checkbox" id="structure-check" checked>
        <label for="structure-check">Структуру иконки</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет наличие слоя Color-layer и правильное размещение Vector внутри него.</div>
        </div>
      </div>
      <div class="settings-item dependent-item">
        <input type="checkbox" id="constraints-check" checked>
        <label for="constraints-check">Выравнивание в контейнере</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет, что слой Color-layer выровнен по центру (CENTER для horizontal и vertical constraints). Зависит от проверки структуры, так как требует наличия слоя Color-layer.</div>
        </div>
      </div>
      <div class="settings-item dependent-item">
        <input type="checkbox" id="vector-check" checked>
        <label for="vector-check">Слой Vector</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет, что слой Vector заблокирован, имеет тип VECTOR и не имеет собственного цвета. Зависит от проверки структуры, так как требует наличия слоя Vector внутри Color-layer.</div>
        </div>
      </div>
      
      <div class="settings-item">
        <input type="checkbox" id="editGroup-check" checked>
        <label for="editGroup-check">Наличие исходника иконки</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет наличие и скрытость объекта с именем "Edit" или "edit" для хранения исходника иконки. Объект может быть любого типа: фрейм, группа, объединение и другие. При исправлении создается скрытый фрейм размером варианта компонента.</div>
        </div>
      </div>

      <div class="settings-item">
        <input type="checkbox" id="noStroke-check" checked>
        <label for="noStroke-check">Отсутствие обводки у слоев</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Проверяет, что слои Color-layer и Vector не имеют обводки (Stroke). Иконки должны использовать только заливку fill.</div>
        </div>
      </div>

      <div class="settings-item">
        <input type="checkbox" id="excludeDotNames-check" checked>
        <label for="excludeDotNames-check">Исключать компоненты с точкой</label>
        <div class="tooltip-icon">?
          <div class="tooltip">Исключает из проверки компоненты, названия которых начинаются с точки (например, .orb-icon-test). Полезно для временных или специальных компонентов.</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="content-container">
    <div id="progress-container" class="progress-container" style="display: none;">
      <div class="progress-bar">
        <div id="progress-fill" class="progress-fill"></div>
      </div>
      <div id="progress-text" class="progress-text">0%</div>
    </div>
    
    <div id="status" class="loading" style="display: none;">
      Проверка иконок, имей терпение...
    </div>
    
    <div id="error-container" style="display: none;"></div>
    
    <div id="results-container" class="results-container"></div>
  </div>

  <script>
    // Флаг отладочного режима (можно изменить на false для продакшена)
    const DEBUG_MODE = false;
    
    // Функция для условного логирования
    function debugLog(...args) {
      if (DEBUG_MODE) {
        console.log(...args);
      }
    }
    
    // Функция для условного предупреждения
    function debugWarn(...args) {
      if (DEBUG_MODE) {
        console.warn(...args);
      }
    }
    
    // Получаем элементы UI
    const checkButton = document.getElementById('check-button');
    const statusElement = document.getElementById('status');
    const resultsContainer = document.getElementById('results-container');
    const progressContainer = document.getElementById('progress-container');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const errorContainer = document.getElementById('error-container');
    const settingsButton = document.getElementById('settings-button');
    const settingsDropdown = document.getElementById('settings-dropdown');
    const errorBadge = document.getElementById('error-badge');
    
    // Настройки проверок
    const checkboxes = {
      naming: document.getElementById('naming-check'),
      variants: document.getElementById('variants-check'),
      sizes: document.getElementById('sizes-check'),
      structure: document.getElementById('structure-check'),
      constraints: document.getElementById('constraints-check'),
      vector: document.getElementById('vector-check'),
      editGroup: document.getElementById('editGroup-check'),
      description: document.getElementById('description-check'),
      noStroke: document.getElementById('noStroke-check'),
      excludeDotNames: document.getElementById('excludeDotNames-check')
    };
    
    // Чекбокс "Все проверки"
    const allChecksCheckbox = document.getElementById('all-checks');
    
    // Обновляет состояние чекбоксов с учетом зависимостей
    function updateCheckboxStates() {
      // Проверяем, что checkboxes определены
      if (!checkboxes) {
        debugWarn('updateCheckboxStates: checkboxes не определены');
        return;
      }
      
      // Простая логика зависимостей
      const constraintsCheckbox = checkboxes.constraints;
      const vectorCheckbox = checkboxes.vector;
      const descriptionCheckbox = checkboxes.description;
      const structureCheckbox = checkboxes.structure;
      const variantsCheckbox = checkboxes.variants;
      
      // constraints зависит от structure
      if (constraintsCheckbox && structureCheckbox) {
        if (!structureCheckbox.checked) {
          constraintsCheckbox.checked = false;
          constraintsCheckbox.disabled = true;
        } else {
          constraintsCheckbox.disabled = false;
        }
      }
      
      // vector зависит от structure
      if (vectorCheckbox && structureCheckbox) {
        if (!structureCheckbox.checked) {
          vectorCheckbox.checked = false;
          vectorCheckbox.disabled = true;
        } else {
          vectorCheckbox.disabled = false;
        }
      }
      
      // description частично зависит от variants
      if (descriptionCheckbox && variantsCheckbox) {
        if (!variantsCheckbox.checked) {
          descriptionCheckbox.checked = false;
          descriptionCheckbox.disabled = true;
        } else {
          descriptionCheckbox.disabled = false;
        }
      }
    }
    
    // Обработчик изменения чекбокса "Все проверки"
    allChecksCheckbox.addEventListener('change', () => {
      // Устанавливаем все чекбоксы в то же состояние, что и "Все проверки"
      for (const checkbox of Object.values(checkboxes)) {
        checkbox.checked = allChecksCheckbox.checked;
      }
      
      // Обновляем состояние чекбоксов с учетом зависимостей
      updateCheckboxStates();
    });
    
    // Создаем дебаунсированную функцию для обновления настроек
    const debouncedUpdateSettings = debounce(() => {
      // Получаем настройки из чекбоксов
      const settings = {};
      for (const [key, checkbox] of Object.entries(checkboxes)) {
        settings[key] = checkbox.checked;
      }
      
      // Отправляем настройки в плагин
      parent.postMessage({
        pluginMessage: {
          type: 'update-settings',
          settings: settings
        }
      }, '*');
    }, 300); // Задержка в 300 мс
    
    // Добавляем обработчики событий для чекбоксов
    for (const [key, checkbox] of Object.entries(checkboxes)) {
      checkbox.addEventListener('change', () => {
        // Обновляем состояние всех чекбоксов
        updateCheckboxStates();
        
        // Обновляем состояние чекбокса "Все проверки"
        updateAllChecksState();
        
        // Обновляем настройки в плагине с debounce
        debouncedUpdateSettings();
      });
    }
    
    /**
     * Обновляет состояние чекбокса "Все проверки" на основе состояния других чекбоксов
     */
    function updateAllChecksState() {
      // Проверяем, что checkboxes и allChecksCheckbox определены
      if (!checkboxes || !allChecksCheckbox) {
        debugWarn('updateAllChecksState: checkboxes или allChecksCheckbox не определены');
        return;
      }
      
      // Проверяем, все ли чекбоксы включены
      const checkboxValues = Object.values(checkboxes);
      if (checkboxValues.length === 0) {
        debugWarn('updateAllChecksState: нет чекбоксов для проверки');
        return;
      }
      
      const allEnabled = checkboxValues.every(checkbox => checkbox && checkbox.checked);
      
      // Устанавливаем состояние чекбокса "Все проверки"
      allChecksCheckbox.checked = allEnabled;
    }
    
    // Текущие результаты проверки
    let currentResults = [];
    
    // Флаг для отслеживания состояния проверки
    let isCheckingInProgress = false;
    
    // Сохраняем исходное выделение перед фокусировкой на ошибку
    let savedSelection = null;
    
    // Обработчик клика на кнопку настроек с защитой от двойного клика
    const toggleSettingsDropdown = debounce(() => {
      if (settingsDropdown.style.display === 'block') {
        settingsDropdown.style.display = 'none';
      } else {
        settingsDropdown.style.display = 'block';
        // Обновляем состояние чекбоксов при открытии настроек
        updateCheckboxStates();
      }
    }, 200);
    
    // Добавляем обработчик клика
    settingsButton.addEventListener('click', toggleSettingsDropdown);
    
    // Обработчик клика на кнопку "Проверить иконки"
    checkButton.addEventListener('click', () => {
      if (isCheckingInProgress) {
        // Если проверка уже запущена, останавливаем ее
        isCheckingInProgress = false;
        
        // Отправляем сообщение в плагин для остановки проверки
        parent.postMessage({
          pluginMessage: {
            type: 'stop-check'
          }
        }, '*');
        
        // Возвращаем кнопке исходный вид
        checkButton.textContent = 'Проверить';
        checkButton.style.backgroundColor = '#F86025';
        
        // Обновляем статус
        statusElement.textContent = 'Проверка остановлена';
        
        return;
      }
      
      // Если проверка не запущена, запускаем ее
      isCheckingInProgress = true;
      
      // Меняем заголовок на Icons Checker
      const headerTitle = document.querySelector('h1');
      if (headerTitle) {
        headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;Icons Checker';
      }
      
      // Меняем текст и цвет кнопки
      checkButton.textContent = 'Остановить проверку';
      checkButton.style.backgroundColor = '#E74C3C';
      
      // Показываем статус загрузки и прогресс
      statusElement.style.display = 'block';
      progressContainer.style.display = 'block';
      progressFill.style.width = '0%';
      progressText.textContent = '0%';
      resultsContainer.innerHTML = '';
      errorContainer.style.display = 'none';
      errorContainer.innerHTML = '';
      // Скрываем счетчик ошибок при начале проверки
      errorBadge.style.display = 'none';
      
      // Получаем настройки проверок
      const settings = {};
      for (const [key, checkbox] of Object.entries(checkboxes)) {
        settings[key] = checkbox.checked;
      }
      
      // Отправляем сообщение в плагин для проверки иконок
      parent.postMessage({
        pluginMessage: {
          type: 'check-icons',
          settings: settings,
          saveSelection: true  // Просим сохранить текущее выделение
        }
      }, '*');
    });
    
    
    // Обработчик клика на кнопку "Создать Cell"
    document.getElementById('create-cell-button').addEventListener('click', () => {
      // Отправляем сообщение в плагин для создания Cell
      parent.postMessage({
        pluginMessage: {
          type: 'create-cell'
        }
      }, '*');
    });
    
    // Обработчики для получения текста со страницы (только если элементы существуют)
    let getTextButton, textOutputContainer, textTotalNodes, textTotalChars, copyTextButton, downloadTextButton, textStatsSection, textActionsSection, textLoadingIndicator;
    let currentText = '';
    
    function initGetPageTextHandlers() {
      getTextButton = document.getElementById('get-text-button');
      textOutputContainer = document.getElementById('text-output-container');
      textTotalNodes = document.getElementById('text-total-nodes');
      textTotalChars = document.getElementById('text-total-chars');
      copyTextButton = document.getElementById('copy-text-button');
      downloadTextButton = document.getElementById('download-text-button');
      textStatsSection = document.getElementById('text-stats-section');
      textActionsSection = document.getElementById('text-actions-section');
      textLoadingIndicator = document.getElementById('text-loading-indicator');
      const exportMarkdownButton = document.getElementById('get-page-export-markdown-button');
      const markdownExportProgress = document.getElementById('markdown-export-progress');
      
      // Обработчик экспорта в Markdown (только для get-page-text секции)
      if (exportMarkdownButton) {
        console.log('Найдена кнопка экспорта в Markdown для get-page-text');
        exportMarkdownButton.addEventListener('click', async () => {
          console.log('Кнопка экспорта в Markdown нажата');
          
          if (markdownExportProgress) {
            markdownExportProgress.style.display = 'block';
            const progressText = document.getElementById('markdown-progress-text');
            const progressBar = document.getElementById('markdown-progress-bar');
            if (progressText) {
              progressText.textContent = 'Экспорт в Markdown...';
              progressText.style.color = '#AAAAAA';
            }
            if (progressBar) progressBar.style.width = '0%';
          }
          
          try {
          // Получаем настройки из полей
          const docBlocks = document.getElementById('md-doc-blocks').value.split(',').map(s => s.trim()).filter(s => s);
          const headingComponent = document.getElementById('md-heading-component').value.trim();
          const textComponent = document.getElementById('md-text-component').value.trim();
          const previewFrame = document.getElementById('md-preview-frame').value.trim();
          const useIndentation = document.getElementById('md-use-indentation').checked;
          const onlyDocBlocks = document.getElementById('md-only-doc-blocks').checked;
          
          // Получаем настройки маппинга размеров заголовков
          const sizeLg = parseInt(document.getElementById('md-size-lg').value) || 1;
          const sizeMd = parseInt(document.getElementById('md-size-md').value) || 2;
          const sizeSm = parseInt(document.getElementById('md-size-sm').value) || 3;
          const sizeXs = parseInt(document.getElementById('md-size-xs').value) || 4;
          
          // Получаем список исключенных компонентов
          const excludedComponentsInput = document.getElementById('md-excluded-components');
          const excludedComponents = excludedComponentsInput ? 
            excludedComponentsInput.value.split(',').map(s => s.trim()).filter(s => s) : 
            ['sourse-Info'];
          
          parent.postMessage({
            pluginMessage: {
              type: 'export-to-markdown',
              includeHidden: false,
              settings: {
                documentationBlocks: docBlocks,
                headingComponentName: headingComponent,
                textComponentName: textComponent,
                previewFrameName: previewFrame,
                headingSizeMapping: {
                  lg: sizeLg,
                  md: sizeMd,
                  sm: sizeSm,
                  xs: sizeXs
                },
                excludedComponents: excludedComponents,
                useIndentation: useIndentation,
                onlyDocumentationBlocks: onlyDocBlocks
              }
            }
          }, '*');
          } catch (error) {
            console.error('Ошибка при отправке сообщения:', error);
            alert('Ошибка при запуске экспорта: ' + error.message);
          }
        });
      } else {
        console.warn('Кнопка export-markdown-button не найдена');
      }
      
      if (getTextButton) {
        getTextButton.addEventListener('click', () => {
          // Отправляем сообщение в плагин для получения текста
          parent.postMessage({
            pluginMessage: {
              type: 'get-all-text-from-page',
              includeHidden: false
            }
          }, '*');
          
          // Показываем индикатор загрузки
          if (textLoadingIndicator) textLoadingIndicator.style.display = 'block';
          if (textOutputContainer) {
            textOutputContainer.style.display = 'none';
          }
          if (textStatsSection) textStatsSection.style.display = 'none';
          if (textActionsSection) textActionsSection.style.display = 'none';
        });
      }
      
      if (copyTextButton) {
        copyTextButton.addEventListener('click', () => {
          if (!currentText) return;
          
          // Копируем текст в буфер обмена
          navigator.clipboard.writeText(currentText).then(() => {
            copyTextButton.textContent = 'Скопировано!';
            setTimeout(() => {
              copyTextButton.textContent = 'Копировать';
            }, 2000);
          }).catch(err => {
            console.error('Ошибка при копировании:', err);
            copyTextButton.textContent = 'Ошибка';
            setTimeout(() => {
              copyTextButton.textContent = 'Копировать';
            }, 2000);
          });
        });
      }
      
      if (downloadTextButton) {
        downloadTextButton.addEventListener('click', () => {
          if (!currentText) return;
          
          // Создаем blob и скачиваем
          const blob = new Blob([currentText], { type: 'text/plain;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `figma-page-text-${new Date().toISOString().slice(0, 10)}.txt`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          downloadTextButton.textContent = 'Скачано!';
          setTimeout(() => {
            downloadTextButton.textContent = 'Скачать';
          }, 2000);
        });
      }
    }
    
    // Инициализируем обработчики при загрузке
    initGetPageTextHandlers();
    

    // Node ID Inspector элементы
    const getNodeIdButton = document.getElementById('get-node-id-button');
    const compareIdsButton = document.getElementById('compare-ids-button');
    const currentNodeIdDisplay = document.getElementById('current-node-id');
    const nodeIdsTextarea = document.getElementById('node-ids-textarea');
    const comparisonResult = document.getElementById('comparison-result');

    // SVG Export элементы
    const scanIconsButton = document.getElementById('scan-icons-button');
    const exportIconsButton = document.getElementById('export-icons-button');
    const exportStats = document.getElementById('export-stats');
    const componentSetsCount = document.getElementById('component-sets-count');
    const totalVariantsCount = document.getElementById('total-variants-count');
    const exportInfo = document.getElementById('export-info');
    const colorOptions = document.getElementById('color-options');
    const applyFillColorCheckbox = document.getElementById('apply-fill-color');
    const colorSelection = document.getElementById('color-selection');
    const customFillColor = document.getElementById('custom-fill-color');
    const customFillHex = document.getElementById('custom-fill-hex');
    const colorPresetButtons = document.querySelectorAll('.color-preset-btn');
    
    // Элементы детального прогрессбара для SVG экспорта
    const svgExportProgress = document.getElementById('svg-export-progress');
    const exportProgressText = document.getElementById('export-progress-text');
    const exportCounter = document.getElementById('export-counter');
    const exportProgressFill = document.getElementById('export-progress-fill');
    const exportPercentage = document.getElementById('export-percentage');
    const exportCurrentIcon = document.getElementById('export-current-icon');
    const exportSpeed = document.getElementById('export-speed');
    const exportElapsedTime = document.getElementById('export-elapsed-time');
    const exportRemainingTime = document.getElementById('export-remaining-time');
    
    // Переменные для отслеживания времени и скорости
    let exportStartTime = null;
    let lastUpdateTime = null;
    let lastProcessedCount = 0;
    
    // Переменная для хранения данных сканирования
    let scannedComponentSets = [];
    
    // Переменная для хранения SVG файлов для создания архива
    let svgFiles = [];
    let expectedFilesCount = 0;
    
    // Переменная для хранения выбранного цвета fill
    let selectedFillColor = '#000000';

    // Обработчик клика на кнопку "Получить ID выделенного"
    getNodeIdButton.addEventListener('click', () => {
      // Отправляем сообщение в плагин для получения ID выделенного объекта
      parent.postMessage({
        pluginMessage: {
          type: 'get-selected-node-id'
        }
      }, '*');
    });

    // Обработчик клика на кнопку "Сравнить ID"
    compareIdsButton.addEventListener('click', () => {
      compareNodeIds();
    });

    // Обработчик клика на кнопку "Сканировать страницу"
    scanIconsButton.addEventListener('click', () => {
        debugLog('SVG Export: Начинаем сканирование страницы');
      
      // Отправляем сообщение в плагин для сканирования иконок
      parent.postMessage({
        pluginMessage: {
          type: 'scan-icons-for-export'
        }
      }, '*');
      
      // Показываем индикатор загрузки
      scanIconsButton.textContent = 'Сканируем...';
      scanIconsButton.disabled = true;
    });

    // Обработчик клика на кнопку "Анализировать компоненты"
    const analyzeComponentPropertiesButton = document.getElementById('analyze-component-properties-button');
    if (analyzeComponentPropertiesButton) {
      analyzeComponentPropertiesButton.addEventListener('click', () => {
        debugLog('Component Properties Analysis: Начинаем анализ компонентов');
        
        // Показываем прогресс
        const progress = document.getElementById('component-properties-progress');
        const progressFill = document.getElementById('component-properties-progress-fill');
        const progressText = document.getElementById('component-properties-progress-text');
        
        if (progress) {
          progress.style.display = 'block';
          progressFill.style.width = '0%';
          progressText.textContent = 'Анализ компонентов...';
        }
        
        // Отправляем сообщение в плагин для анализа свойств
        parent.postMessage({
          pluginMessage: {
            type: 'analyze-component-properties'
          }
        }, '*');
      });
    }

    // Обработчик клика на кнопку "Экспортировать свойства"
    const exportComponentPropertiesButton = document.getElementById('export-component-properties-button');
    if (exportComponentPropertiesButton) {
      exportComponentPropertiesButton.addEventListener('click', () => {
        debugLog('Component Properties Export: Начинаем экспорт свойств');
        
        // Показываем прогресс
        const progress = document.getElementById('component-properties-progress');
        const progressFill = document.getElementById('component-properties-progress-fill');
        const progressText = document.getElementById('component-properties-progress-text');
        
        if (progress) {
          progress.style.display = 'block';
          progressFill.style.width = '0%';
          progressText.textContent = 'Подготовка...';
        }
        
        // Отправляем сообщение в плагин для экспорта свойств
        parent.postMessage({
          pluginMessage: {
            type: 'export-component-properties'
          }
        }, '*');
      });
    }

    // Обработчики кнопок скачивания
    const downloadJsonButton = document.getElementById('download-json-button');
    const downloadCsvButton = document.getElementById('download-csv-button');
    
    if (downloadJsonButton) {
      downloadJsonButton.addEventListener('click', () => {
        if (window.componentPropertiesJson) {
          downloadFile('component-properties.json', window.componentPropertiesJson, 'application/json');
        }
      });
    }
    
    if (downloadCsvButton) {
      downloadCsvButton.addEventListener('click', () => {
        if (window.componentPropertiesCsv) {
          downloadFile('component-properties.csv', window.componentPropertiesCsv, 'text/csv;charset=utf-8;');
        }
      });
    }

    // Обработчики для выбора цвета fill
    applyFillColorCheckbox.addEventListener('change', () => {
      if (applyFillColorCheckbox.checked) {
        colorSelection.style.display = 'block';
      } else {
        colorSelection.style.display = 'none';
      }
    });

    // Обработчики для кнопок предустановленных цветов
    colorPresetButtons.forEach(button => {
      button.addEventListener('click', () => {
        const color = button.getAttribute('data-color');
        setSelectedColor(color);
        updateActiveColorButton(button);
        
        // Обновляем поля кастомного цвета
        customFillColor.value = color;
        customFillHex.value = color.toUpperCase();
      });
    });

    // Синхронизация цветового пикера и текстового поля
    customFillColor.addEventListener('change', () => {
      const color = customFillColor.value.toUpperCase();
      setSelectedColor(color);
      customFillHex.value = color;
      
      // Проверяем, соответствует ли цвет одному из предустановленных
      const matchingButton = document.querySelector(`.color-preset-btn[data-color="${color}"]`);
      updateActiveColorButton(matchingButton);
    });

    customFillHex.addEventListener('input', () => {
      const color = customFillHex.value.toUpperCase();
      if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
        setSelectedColor(color);
        customFillColor.value = color;
        
        // Проверяем, соответствует ли цвет одному из предустановленных
        const matchingButton = document.querySelector(`.color-preset-btn[data-color="${color}"]`);
        updateActiveColorButton(matchingButton);
      }
    });

    // Функция для установки выбранного цвета
    function setSelectedColor(color) {
      selectedFillColor = color.toUpperCase();
      debugLog('SVG Export: Выбран цвет fill:', selectedFillColor);
      
      // Обновляем визуальный индикатор цвета в текстовом поле
      if (customFillHex) {
        customFillHex.style.setProperty('--selected-color', selectedFillColor);
        customFillHex.classList.add('has-color');
      }
    }

    // Функция для обновления активной кнопки цвета
    function updateActiveColorButton(activeButton) {
      colorPresetButtons.forEach(btn => btn.classList.remove('active'));
      if (activeButton) {
        activeButton.classList.add('active');
      }
    }

    // Обработчик клика на кнопку "Экспортировать все SVG"
    exportIconsButton.addEventListener('click', () => {
      debugLog('SVG Export: Начинаем экспорт, найдено компонент-сетов:', scannedComponentSets.length);
      
      if (scannedComponentSets.length === 0) {
        debugLog('SVG Export: Ошибка - нет данных для экспорта');
        displayMessage({
          type: 'error',
          message: 'Сначала нужно просканировать страницу'
        });
        return;
      }
      
      debugLog('SVG Export: Отправляем сообщение на экспорт с данными:', scannedComponentSets);
      
      // Очищаем массив файлов и подсчитываем ожидаемое количество
      svgFiles = [];
      expectedFilesCount = scannedComponentSets.reduce((sum, cs) => sum + cs.variants, 0);
      debugLog('SVG Export: Ожидается файлов:', expectedFilesCount);

      // Получаем настройки цвета
      const fillColorSettings = {
        applyFillColor: applyFillColorCheckbox.checked,
        fillColor: selectedFillColor
      };
      
      debugLog('SVG Export: Настройки цвета:', fillColorSettings);
      
      // Отправляем сообщение в плагин для экспорта иконок
      parent.postMessage({
        pluginMessage: {
          type: 'export-icons-to-svg',
          componentSets: scannedComponentSets,
          colorSettings: fillColorSettings
        }
      }, '*');
      
      // Показываем индикатор загрузки
      exportIconsButton.textContent = 'Экспортируем...';
      exportIconsButton.disabled = true;
      
      // Показываем детальный прогрессбар для SVG экспорта
      svgExportProgress.style.display = 'block';
      exportProgressFill.style.width = '0%';
      exportProgressText.textContent = 'Начинаем экспорт...';
      exportCounter.textContent = `0/${expectedFilesCount}`;
      exportPercentage.textContent = '0%';
      exportCurrentIcon.textContent = 'Подготовка...';
      
      // Инициализируем переменные времени
      exportStartTime = Date.now();
      lastUpdateTime = Date.now();
      lastProcessedCount = 0;
      exportSpeed.textContent = '0 иконок/сек';
      exportElapsedTime.textContent = 'Время: 0с';
      exportRemainingTime.textContent = 'Осталось: ~0с';
      
      // Скрываем обычный прогрессбар (он для проверки иконок)
      progressContainer.style.display = 'none';
    });

    // Функция сравнения Node ID
    function compareNodeIds() {
      const idsText = nodeIdsTextarea.value.trim();
      
      if (!idsText) {
        showComparisonResult('Введите ID в текстовое поле для сравнения', 'info');
        return;
      }

      // Разбиваем текст на строки и фильтруем пустые
      const ids = idsText.split('\n').map(id => id.trim()).filter(id => id.length > 0);

      if (ids.length < 2) {
        showComparisonResult('Для сравнения необходимо минимум 2 ID', 'info');
        return;
      }

      // Проверяем, все ли ID одинаковые
      const firstId = ids[0];
      const allSame = ids.every(id => id === firstId);

      if (allSame) {
        showComparisonResult(`Все ${ids.length} ID одинаковые: ${firstId}`, 'match');
      } else {
        // Находим уникальные ID
        const uniqueIds = [...new Set(ids)];
        showComparisonResult(`Найдено ${uniqueIds.length} разных ID из ${ids.length} всего:
${uniqueIds.map((id, index) => `${index + 1}. ${id}`).join('\n')}`, 'no-match');
      }
    }

    // Функция отображения результата сравнения
    function showComparisonResult(message, type) {
      comparisonResult.textContent = message;
      comparisonResult.className = `comparison-result ${type}`;
      comparisonResult.style.display = 'block';
      
      // Скрываем результат через 10 секунд
      setTimeout(() => {
        comparisonResult.style.display = 'none';
      }, 10000);
    }
    
    // ============================================
    // AI Design Lint функции (объявляем рано для использования в обработчиках)
    // ============================================
    
    // Функция отправки запроса к Yandex Eliza API
    async function sendToElizaAPI(designInfo, userPrompt, token) {
      try {
        debugLog('AI Design Lint: Отправляем запрос к Eliza API');
        debugLog('AI Design Lint: Структура designInfo:', {
          hasDesignSystem: !!designInfo.designSystem,
          hasVariables: designInfo.designSystem ? !!designInfo.designSystem.variables : false,
          hasRules: designInfo.designSystem ? !!designInfo.designSystem.rules : false,
          elementsCount: designInfo.elements ? designInfo.elements.length : 0
        });
        
        // Формируем информацию о доступных токенах дизайн-системы
        let designSystemContext = '';
        if (designInfo.designSystem && designInfo.designSystem.variables) {
          const ds = designInfo.designSystem;
          
          // Формируем информацию о токенах
          let tokensInfo = 'ДОСТУПНЫЕ ТОКЕНЫ ДИЗАЙН-СИСТЕМЫ ORBITA:\n\n';
          
          if (ds.variables.colors && ds.variables.colors.length > 0) {
            tokensInfo += `Цвета: ${ds.variables.colors.length} токенов (топ: ${ds.variables.colors.slice(0, 5).map(v => v.name).join(', ')})\n`;
          }
          
          if (ds.variables.spacing && ds.variables.spacing.length > 0) {
            tokensInfo += `Spacing: ${ds.variables.spacing.length} токенов (топ: ${ds.variables.spacing.slice(0, 5).map(v => v.name).join(', ')})\n`;
          }
          
          if (ds.variables.typography && ds.variables.typography.length > 0) {
            tokensInfo += `Typography: ${ds.variables.typography.length} токенов (топ: ${ds.variables.typography.slice(0, 5).map(v => v.name).join(', ')})\n`;
          }
          
          // Формируем информацию о правилах
          let rulesInfo = 'ПРАВИЛА ДИЗАЙН-СИСТЕМЫ:\n';
          if (ds.rules) {
            if (ds.rules.spacing) {
              rulesInfo += `- Spacing: ${ds.rules.spacing.description} (стандартные: ${ds.rules.spacing.standard.join(', ')}px)\n`;
            }
            if (ds.rules.cornerRadius) {
              rulesInfo += `- Border Radius: ${ds.rules.cornerRadius.description} (стандартные: ${ds.rules.cornerRadius.standard.join(', ')}px)\n`;
            }
            if (ds.rules.touchTargets) {
              rulesInfo += `- Touch Targets: ${ds.rules.touchTargets.description} (минимум ${ds.rules.touchTargets.minimum}px)\n`;
            }
            if (ds.rules.contrast) {
              rulesInfo += `- Contrast: ${ds.rules.contrast.description} (обычный текст: ${ds.rules.contrast.normalText}:1, крупный текст: ${ds.rules.contrast.largeText}:1)\n`;
            }
          } else {
            // Правила по умолчанию, если не загружены из файла
            rulesInfo += `- Spacing: Все отступы должны быть кратны 4px (стандартные: 0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 56, 64px)\n`;
            rulesInfo += `- Border Radius: Стандартные значения (0, 2, 4, 6, 8, 12, 16, 20, 24, 32px)\n`;
            rulesInfo += `- Touch Targets: Минимальный размер для интерактивных элементов (минимум 44px)\n`;
            rulesInfo += `- Contrast: Минимальный контраст по WCAG AA (обычный текст: 4.5:1, крупный текст: 3.0:1)\n`;
          }
          
          designSystemContext = tokensInfo + rulesInfo;
        }
        
        // Добавляем кастомную дизайн-систему, если загружена (сокращённая версия)
        if (customDesignSystemJson) {
          designSystemContext += '\n\nКАСТОМНАЯ ДИЗАЙН-СИСТЕМА:\n';
          
          // Добавляем только ключевую информацию из JSON
          if (customDesignSystemJson.tokens) {
            designSystemContext += 'Кастомные токены: ';
            const tokenCategories = Object.keys(customDesignSystemJson.tokens);
            designSystemContext += tokenCategories.join(', ') + '\n';
          }
          
          if (customDesignSystemJson.rules) {
            designSystemContext += 'Правила: ' + Object.keys(customDesignSystemJson.rules).join(', ') + '\n';
          }
          
          designSystemContext += 'ИСПОЛЬЗУЙ данные из кастомной дизайн-системы для рекомендаций.\n';
          debugLog('AI Design Lint: Добавлена кастомная дизайн-система в промпт (сокращённая)');
        }
        
        // Ограничиваем количество элементов для анализа (чтобы не превысить лимит токенов)
        const MAX_ELEMENTS = 20;
        let elementsToAnalyze = designInfo.elements;
        let isLimited = false;
        
        if (elementsToAnalyze.length > MAX_ELEMENTS) {
          isLimited = true;
          elementsToAnalyze = elementsToAnalyze.slice(0, MAX_ELEMENTS);
          debugLog(`AI Design Lint: Ограничено до ${MAX_ELEMENTS} элементов из ${designInfo.elements.length}`);
          
          // Показываем предупреждение пользователю
          if (aiAnalysisResult) {
            const warning = document.createElement('div');
            warning.style.cssText = 'background: #FF9800; color: #000; padding: 8px 12px; border-radius: 8px; margin-bottom: 12px; font-size: 11px; line-height: 1.4;';
            warning.innerHTML = `⚠️ <strong>Внимание:</strong> Выбрано ${designInfo.elements.length} элементов. Для экономии токенов будут проанализированы только первые ${MAX_ELEMENTS}. Для полного анализа выберите меньше элементов.`;
            aiAnalysisResult.insertBefore(warning, aiAnalysisResult.firstChild);
          }
        }
        
        // Оптимизируем данные для отправки (убираем избыточную информацию)
        const optimizedElements = elementsToAnalyze.map(el => {
          const optimized = {
            id: el.id,
            name: el.name,
            type: el.type,
            width: el.width,
            height: el.height
          };
          
          // Добавляем только критичные для анализа поля
          if (el.fills && el.fills.length > 0) {
            optimized.fills = el.fills.map(f => ({
              type: f.type,
              color: f.color,
              isHardcoded: f.isHardcoded,
              variable: f.variable ? { name: f.variable.name } : undefined
            })).filter(f => f.variable || f.isHardcoded);
          }
          
          if (el.autoLayout) {
            optimized.autoLayout = {
              mode: el.autoLayout.mode,
              paddingLeft: el.autoLayout.paddingLeft,
              paddingRight: el.autoLayout.paddingRight,
              paddingTop: el.autoLayout.paddingTop,
              paddingBottom: el.autoLayout.paddingBottom,
              itemSpacing: el.autoLayout.itemSpacing,
              hasNonStandardSpacing: el.autoLayout.hasNonStandardSpacing,
              nonStandardValues: el.autoLayout.nonStandardValues
            };
          }
          
          if (el.fontSize) {
            optimized.fontSize = el.fontSize;
            optimized.fontSizeHardcoded = el.fontSizeHardcoded;
            if (el.fontSizeVariable) {
              optimized.fontSizeVariable = { name: el.fontSizeVariable.name };
            }
          }
          
          if (el.cornerRadius !== undefined) {
            optimized.cornerRadius = el.cornerRadius;
            optimized.nonStandardCornerRadius = el.nonStandardCornerRadius;
          }
          
          // Добавляем дочерние элементы, но только первый уровень
          if (el.children && el.children.length > 0) {
            optimized.childrenCount = el.children.length;
            optimized.childrenTypes = el.childrenTypes;
          }
          
          return optimized;
        });
        
        // Формируем промпт для AI
        const limitNote = isLimited ? `\n\nВНИМАНИЕ: Анализируются первые ${MAX_ELEMENTS} элементов из ${designInfo.elements.length}. Для полного анализа выберите меньше элементов.` : '';
        
        const systemPrompt = `Ты - AI-помощник для анализа Figma компонентов, специализирующийся на дизайн-системе Orbita, доступности и качестве кода. Твоя задача - провести глубокий технический аудит компонента.

ИНФОРМАЦИЯ О КОМПОНЕНТЕ (оптимизировано для анализа):
${JSON.stringify(optimizedElements, null, 2)}${limitNote}

${designSystemContext}

ВАЖНО: В данных компонента каждый элемент имеет свой ID (поле "id"). При обнаружении проблемы ОБЯЗАТЕЛЬНО указывай ID элемента в формате [ID:element_id].

ТРЕБОВАНИЯ К АНАЛИЗУ:

1. **КОНКРЕТНЫЕ ПРОБЛЕМЫ** - Найди реальные проблемы в предоставленных данных:
   - Жестко закодированные значения (hard-coded values) вместо токенов
     * Проверь fills - если нет поля "variable", значит цвет hard-coded
     * Проверь autoLayout - если есть "hasNonStandardSpacing: true" и "nonStandardValues", это проблема
     * Проверь "fontSizeHardcoded: true" - значит размер шрифта не использует токен
   - Несоответствующие размеры (например, отступы 7px вместо стандартных значений)
   - Проблемы с контрастом цветов (проверь RGB значения в fills)
   - Неправильные размеры шрифтов
   - Отсутствующие состояния компонента (hover, disabled, etc)

2. **ACCESSIBILITY AUDIT**:
   - Проверь контраст цветов (используй формулу WCAG: контраст = (L1 + 0.05) / (L2 + 0.05), где L = 0.2126*R + 0.7152*G + 0.0722*B)
   - Проверь размеры для touch targets (минимум 44x44px для интерактивных элементов)
   - Проверь читаемость текста (fontSize должен быть >= 12px для обычного текста)

3. **DESIGN TOKENS**:
   - Укажи, где используются жестко закодированные значения (ищи "isHardcoded: true", "fontSizeHardcoded: true", "hasNonStandardSpacing: true")
   - Предложи конкретные токены из списка доступных токенов дизайн-системы выше
   - Для каждого hard-coded значения укажи ID элемента в формате [ID:element_id]

4. **COMPONENT STRUCTURE**:
   - Проверь правильность Auto Layout настроек (mode, spacing, padding)
   - Проверь именование слоев (name)
   - Проверь соответствие структуре дизайн-системы
   - Проверь cornerRadius на соответствие стандартным значениям (ищи "nonStandardCornerRadius: true")

5. **CODE-READINESS SCORE**:
   - Оцени готовность компонента к передаче в разработку (0-100%)
   - Укажи, что нужно исправить для 100%

ФОРМАТ ОТВЕТА:
Для каждой проблемы используй формат:
[ID:element_id] Описание проблемы
Где element_id - это значение поля "id" проблемного элемента

Примеры:
- НЕ: "Проверьте размеры шрифта"
- ДА: "[ID:123:456] Текст использует fontSize: 13px (hard-coded), рекомендуется заменить на токен text-sm (14px)"
- ДА: "[ID:789:012] Отступ paddingLeft: 7px не соответствует стандартным значениям, используй 8px (spacing-2)"
- ДА: "[ID:345:678] Цвет fill: rgb(0.2, 0.3, 0.4) hard-coded, используй токен color-primary-500"

В конце дай CODE-READINESS SCORE в формате: "Score: XX%" где XX - число от 0 до 100.

Начни с самых критичных проблем.`;

        const userMessage = userPrompt || 'Проанализируй дизайн и дай детальные технические рекомендации с указанием ID проблемных элементов.';
        
        const response = await fetch('https://api.eliza.yandex.net/openai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `OAuth ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              {
                role: 'system',
                content: systemPrompt
              },
              {
                role: 'user',
                content: userMessage
              }
            ],
            temperature: 0.7,
            max_tokens: 2000
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('AI Design Lint: Ошибка API:', response.status, errorText);
          throw new Error(`Ошибка API (${response.status}): ${errorText}`);
        }
        
        const data = await response.json();
        debugLog('AI Design Lint: Получен ответ от API:', data);
        
        // Yandex Eliza API возвращает данные в поле response
        let actualResponse = data;
        if (data.response) {
          actualResponse = data.response;
          debugLog('AI Design Lint: Извлечен response:', actualResponse);
        }
        
        // Проверяем стандартный формат OpenAI (choices)
        if (actualResponse.choices && actualResponse.choices.length > 0) {
          const choice = actualResponse.choices[0];
          const content = choice.message?.content || choice.text;
          if (content) {
            debugLog('AI Design Lint: Успешно получен контент:', content.substring(0, 100) + '...');
            return {
              success: true,
              analysis: content
            };
          }
        }
        
        // Если это другой формат ответа
        if (actualResponse.result) {
          return {
            success: true,
            analysis: actualResponse.result
          };
        }
        
        // Если ответ содержит текст напрямую
        if (actualResponse.content || actualResponse.text) {
          return {
            success: true,
            analysis: actualResponse.content || actualResponse.text
          };
        }
        
        console.error('AI Design Lint: Неожиданная структура ответа:', actualResponse);
        throw new Error(`Некорректный ответ от API. Проверьте консоль для деталей.`);
        
      } catch (error) {
        console.error('AI Design Lint: Ошибка при запросе к API:', error);
        return {
          success: false,
          error: error.message
        };
      }
    }
    
    // Функция отображения результатов AI-анализа
    function displayAIAnalysis(analysis, designInfo) {
      if (!aiAnalysisResult) return;
      
      aiAnalysisResult.style.display = 'block';
      aiAnalysisResult.innerHTML = '';
      
      // Парсим ответ AI для извлечения структурированных данных
      const parsedAnalysis = parseAIAnalysis(analysis, designInfo);
      
      // Отображаем оценку готовности
      if (parsedAnalysis.score !== null) {
        const scoreSection = document.createElement('div');
        scoreSection.style.cssText = 'background: #2A2A32; border-radius: 8px; padding: 12px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;';
        
        const scoreLabel = document.createElement('div');
        scoreLabel.style.cssText = 'font-size: 13px; font-weight: 600; color: #FFFFFF;';
        scoreLabel.textContent = '🏆 Code Readiness Score';
        
        const scoreValue = document.createElement('div');
        scoreValue.style.cssText = `font-size: 18px; font-weight: 700; color: ${parsedAnalysis.score >= 80 ? '#4CAF50' : parsedAnalysis.score >= 60 ? '#FF9800' : '#F02D2D'};`;
        scoreValue.textContent = `${parsedAnalysis.score}%`;
        
        scoreSection.appendChild(scoreLabel);
        scoreSection.appendChild(scoreValue);
        aiAnalysisResult.appendChild(scoreSection);
      }
      
      // Отображаем проблемы по категориям
      if (parsedAnalysis.issues.length > 0) {
        const issuesTitle = document.createElement('h4');
        issuesTitle.style.cssText = 'font-size: 13px; font-weight: 600; margin: 16px 0 12px 0; color: #F86025;';
        issuesTitle.textContent = '⚠️ Найденные проблемы';
        aiAnalysisResult.appendChild(issuesTitle);
        
        parsedAnalysis.issues.forEach(issue => {
          const issueCard = createIssueCard(issue, designInfo);
          aiAnalysisResult.appendChild(issueCard);
        });
      }
      
      // Отображаем полный текст анализа
      const fullAnalysisToggle = document.createElement('div');
      fullAnalysisToggle.style.cssText = 'margin-top: 16px; cursor: pointer; color: #F86025; font-size: 12px; font-weight: 600;';
      fullAnalysisToggle.textContent = '▼ Показать полный анализ';
      
      const fullAnalysisContent = document.createElement('div');
      fullAnalysisContent.style.cssText = 'display: none; margin-top: 8px; padding: 12px; background: #2A2A32; border-radius: 8px; font-size: 12px; line-height: 1.6; white-space: pre-wrap;';
      fullAnalysisContent.textContent = analysis;
      
      fullAnalysisToggle.addEventListener('click', () => {
        const isVisible = fullAnalysisContent.style.display === 'block';
        fullAnalysisContent.style.display = isVisible ? 'none' : 'block';
        fullAnalysisToggle.textContent = isVisible ? '▼ Показать полный анализ' : '▲ Скрыть полный анализ';
      });
      
      aiAnalysisResult.appendChild(fullAnalysisToggle);
      aiAnalysisResult.appendChild(fullAnalysisContent);
      
      // Добавляем кнопку для копирования результатов
      const copyButton = document.createElement('button');
      copyButton.className = 'secondary-button';
      copyButton.textContent = 'Скопировать результаты';
      copyButton.style.width = '100%';
      copyButton.style.marginTop = '12px';
      copyButton.addEventListener('click', () => {
        navigator.clipboard.writeText(analysis)
          .then(() => {
            copyButton.textContent = 'Скопировано!';
            setTimeout(() => {
              copyButton.textContent = 'Скопировать результаты';
            }, 2000);
          })
          .catch(error => {
            console.error('Ошибка при копировании в буфер обмена:', error);
            copyButton.textContent = 'Ошибка копирования';
            setTimeout(() => {
              copyButton.textContent = 'Скопировать результаты';
            }, 2000);
          });
      });
      aiAnalysisResult.appendChild(copyButton);
    }
    
    // Функция парсинга AI-анализа для извлечения структурированных данных
    function parseAIAnalysis(analysis, designInfo) {
      const result = {
        score: null,
        issues: []
      };
      
      // Извлекаем оценку (ищем числа с % или "score: XX")
      const scoreMatch = analysis.match(/(?:score|готовность|readiness)[:\s]*(\d+)%?/i);
      if (scoreMatch) {
        result.score = parseInt(scoreMatch[1]);
      }
      
      // Извлекаем проблемы (ищем маркированные списки и конкретные упоминания)
      const lines = analysis.split('\n');
      let currentCategory = 'general';
      
      lines.forEach(line => {
        line = line.trim();
        
        // Извлекаем element ID из формата [ID:element_id]
        let extractedElementId = null;
        const idMatch = line.match(/\[ID:([^\]]+)\]/);
        if (idMatch) {
          extractedElementId = idMatch[1];
          // Удаляем ID из текста для дальнейшей обработки
          line = line.replace(/\[ID:[^\]]+\]\s*/, '');
          debugLog('AI Design Lint: Найден ID элемента в ответе AI:', extractedElementId);
        }
        
        // Определяем категорию
        if (line.match(/hard.?coded|жестко.?закодирован/i)) {
          currentCategory = 'hardcoded';
        } else if (line.match(/token|токен/i)) {
          currentCategory = 'tokens';
        } else if (line.match(/spacing|отступ/i)) {
          currentCategory = 'spacing';
        } else if (line.match(/color|цвет|contrast|контраст/i)) {
          currentCategory = 'colors';
        } else if (line.match(/accessibility|доступность/i)) {
          currentCategory = 'accessibility';
        }
        
        // Извлекаем конкретные проблемы
        if (line.match(/^[\-\*•]\s+/) || line.match(/^\d+\.\s+/)) {
          const issueText = line.replace(/^[\-\*•\d\.]\s+/, '');
          if (issueText.length > 10) {
            // Используем извлеченный ID из формата [ID:xxx] или ищем упоминание элемента в тексте проблемы
            let elementId = extractedElementId;
            let elementName = null;
            
            // Если ID не извлечен, ищем имена элементов в кавычках или после слов "элемент", "слой", "компонент"
            if (!elementId) {
            const namePatterns = [
              /"([^"]+)"/,           // "имя"
              /«([^»]+)»/,           // «имя»
              /элемент[:\s]+([^\s,\.]+)/i,
              /слой[:\s]+([^\s,\.]+)/i,
              /компонент[:\s]+([^\s,\.]+)/i,
              /layer[:\s]+([^\s,\.]+)/i,
              /component[:\s]+([^\s,\.]+)/i
            ];
            
            for (const pattern of namePatterns) {
              const match = issueText.match(pattern);
              if (match && designInfo.allNodes) {
                const mentionedName = match[1].trim();
                // Ищем точное совпадение или частичное (если имя содержит упоминаемое)
                const foundNode = designInfo.allNodes.find(n => 
                  n.name === mentionedName || 
                  n.name.toLowerCase().includes(mentionedName.toLowerCase()) ||
                  mentionedName.toLowerCase().includes(n.name.toLowerCase())
                );
                if (foundNode) {
                  elementId = foundNode.id;
                  elementName = foundNode.name;
                  debugLog(`AI Design Lint: Найдена ссылка на элемент "${elementName}" (${elementId})`);
                  break;
                  }
                }
              }
            }
            
            // Если у нас есть ID, попробуем найти имя элемента
            if (elementId && !elementName && designInfo.allNodes) {
              const foundNode = designInfo.allNodes.find(n => n.id === elementId);
              if (foundNode) {
                elementName = foundNode.name;
                debugLog(`AI Design Lint: Найдено имя для ID ${elementId}: "${elementName}"`);
              }
            }
            
            result.issues.push({
              category: currentCategory,
              text: issueText,
              severity: line.includes('критич') || line.includes('critical') ? 'high' : 'medium',
              elementId: elementId,
              elementName: elementName
            });
          }
        }
      });
      
      // Если не нашли структурированные проблемы, создаем из элементов дизайна
      if (result.issues.length === 0 && designInfo.elements) {
        designInfo.elements.forEach(element => {
          // Проверяем hard-coded цвета
          if (element.fills) {
            element.fills.forEach(fill => {
              if (fill.isHardcoded && fill.color) {
                result.issues.push({
                  category: 'hardcoded',
                  text: `Элемент "${element.name}" использует hard-coded цвет вместо токена`,
                  severity: 'medium',
                  elementId: element.id,
                  elementName: element.name
                });
              }
            });
          }
          
          // Проверяем нестандартные отступы
          if (element.autoLayout && element.autoLayout.hasNonStandardSpacing) {
            result.issues.push({
              category: 'spacing',
              text: `Элемент "${element.name}" использует нестандартные отступы: ${element.autoLayout.nonStandardValues.join(', ')}px`,
              severity: 'medium',
              elementId: element.id,
              elementName: element.name
            });
          }
          
          // Проверяем hard-coded размеры шрифта
          if (element.fontSizeHardcoded) {
            result.issues.push({
              category: 'hardcoded',
              text: `Текст "${element.name}" использует hard-coded размер шрифта: ${element.fontSize}px`,
              severity: 'medium',
              elementId: element.id,
              elementName: element.name
            });
          }
        });
      }
      
      return result;
    }
    
    // Функция создания карточки проблемы
    function createIssueCard(issue, designInfo) {
      const card = document.createElement('div');
      card.style.cssText = 'background: #44444C; border-radius: 8px; padding: 10px 12px; margin-bottom: 8px; border-left: 3px solid ' + 
        (issue.severity === 'high' ? '#F02D2D' : '#FF9800');
      
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;';
      
      const categoryBadge = document.createElement('span');
      categoryBadge.style.cssText = 'font-size: 10px; font-weight: 600; padding: 2px 6px; border-radius: 4px; background: #2A2A32; color: #F86025; text-transform: uppercase;';
      categoryBadge.textContent = getCategoryLabel(issue.category);
      
      header.appendChild(categoryBadge);
      
      // Если есть elementId, добавляем кнопку перехода
      if (issue.elementId) {
        const focusButton = document.createElement('button');
        focusButton.style.cssText = 'background: #505059; color: white; border: none; border-radius: 6px; padding: 4px 8px; font-size: 11px; cursor: pointer; font-weight: 500;';
        focusButton.textContent = '→ Перейти';
        focusButton.addEventListener('click', () => {
          parent.postMessage({
            pluginMessage: {
              type: 'focus-node',
              nodeId: issue.elementId
            }
          }, '*');
        });
        header.appendChild(focusButton);
      }
      
      card.appendChild(header);
      
      const text = document.createElement('div');
      text.style.cssText = 'font-size: 12px; line-height: 1.5; color: #FFFFFF;';
      text.textContent = issue.text;
      card.appendChild(text);
      
      return card;
    }
    
    // Функция получения метки категории
    function getCategoryLabel(category) {
      const labels = {
        'hardcoded': '🔧 Hard-coded',
        'tokens': '🎨 Tokens',
        'spacing': '📏 Spacing',
        'colors': '🎨 Colors',
        'accessibility': '♿ A11y',
        'general': '📋 General'
      };
      return labels[category] || '📋 General';
    }
    
    // Функция для настройки UI в зависимости от режима
    function setupUIMode(mode) {
      const body = document.body;
      const mainFunctionality = document.querySelectorAll('.button-container, #settings-dropdown, .content-container');
      const nodeIdSection = document.getElementById('node-id-section');
      const svgExportSection = document.getElementById('svg-export-section');
      const aiDesignLintSection = document.getElementById('ai-design-lint-section');
      const dsvSection = document.getElementById('design-system-validator-section');
      const getPageTextSection = document.getElementById('get-page-text-section');
      const componentPropertiesSection = document.querySelector('.component-properties-export-section');
      const headerTitle = document.querySelector('h1');
      const errorBadge = document.getElementById('error-badge');
      
      // Сбрасываем все режимы
      body.classList.remove('node-id-mode', 'svg-export-mode', 'ai-design-lint-mode', 'design-system-validator-mode', 'component-properties-export-mode', 'get-page-text-mode');
      
      if (mode === 'node-id-inspector') {
        // Режим Node ID Inspector
        body.classList.add('node-id-mode');
        
        // Скрываем основную функциональность
        mainFunctionality.forEach(el => {
          if (el) el.style.display = 'none';
        });
        
        // Показываем Node ID Inspector
        if (nodeIdSection) {
          nodeIdSection.style.display = 'block';
          nodeIdSection.style.marginBottom = '0';
        }
        
        // Скрываем SVG Export Section
        if (svgExportSection) {
          svgExportSection.style.display = 'none';
        }
        
        // Меняем заголовок
        if (headerTitle) {
          headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;Node ID Inspector';
        }
        
        // Скрываем badge с ошибками
        if (errorBadge) {
          errorBadge.style.display = 'none';
        }
      } else if (mode === 'component-properties-export') {
        // Режим Component Properties Export
        body.classList.add('component-properties-export-mode');
        
        // Скрываем основную функциональность
        mainFunctionality.forEach(el => {
          if (el) el.style.display = 'none';
        });
        
        // Скрываем Node ID Inspector
        if (nodeIdSection) {
          nodeIdSection.style.display = 'none';
        }
        
        // Скрываем AI Design Lint
        if (aiDesignLintSection) {
          aiDesignLintSection.style.display = 'none';
        }
        
        // Скрываем Design System Validator
        if (dsvSection) {
          dsvSection.style.display = 'none';
        }
        
        // Меняем заголовок
        if (headerTitle) {
          headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;Export Data Components';
        }
        
        // Скрываем badge с ошибками
        if (errorBadge) {
          errorBadge.style.display = 'none';
        }
      } else if (mode === 'svg-export') {
        // Режим SVG Export
        body.classList.add('svg-export-mode');
        
        // Проверяем загрузку JSZip при входе в режим
        debugLog('SVG Export: Переход в режим экспорта, JSZip доступен:', typeof JSZip !== 'undefined');
        
        // Скрываем основную функциональность
        mainFunctionality.forEach(el => {
          if (el) el.style.display = 'none';
        });
        
        // Скрываем Node ID Inspector
        if (nodeIdSection) {
          nodeIdSection.style.display = 'none';
        }
        
        // Показываем SVG Export Section
        if (svgExportSection) {
          svgExportSection.style.display = 'block';
          svgExportSection.style.marginBottom = '0';
        }
        
        // Меняем заголовок
        if (headerTitle) {
          headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;SVG Export';
        }
        
        // Скрываем badge с ошибками
        if (errorBadge) {
          errorBadge.style.display = 'none';
        }
      } else if (mode === 'ai-design-lint') {
        // Режим AI Design Lint
        body.classList.add('ai-design-lint-mode');
        
        // Скрываем основную функциональность
        mainFunctionality.forEach(el => {
          if (el) el.style.display = 'none';
        });
        
        // Скрываем Node ID Inspector и SVG Export
        if (nodeIdSection) {
          nodeIdSection.style.display = 'none';
        }
        
        if (svgExportSection) {
          svgExportSection.style.display = 'none';
        }
        
        // Показываем AI Design Lint Section
        if (aiDesignLintSection) {
          aiDesignLintSection.style.display = 'block';
          aiDesignLintSection.style.marginBottom = '0';
        }
        
        // Меняем заголовок
        if (headerTitle) {
          headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;AI Design Lint';
        }
        
        // Скрываем badge с ошибками
        if (errorBadge) {
          errorBadge.style.display = 'none';
        }
        
        // Загружаем сохраненный токен и JSON
        loadSavedToken();
        loadCustomDesignSystem();
      } else if (mode === 'design-system-validator') {
        // Режим Design System Validator
        body.classList.add('design-system-validator-mode');
        
        // Скрываем основную функциональность
        mainFunctionality.forEach(el => {
          if (el) el.style.display = 'none';
        });
        
        // Скрываем другие секции
        if (nodeIdSection) {
          nodeIdSection.style.display = 'none';
        }
        
        if (svgExportSection) {
          svgExportSection.style.display = 'none';
        }
        
        if (aiDesignLintSection) {
          aiDesignLintSection.style.display = 'none';
        }
        
        // Показываем Design System Validator Section
        if (dsvSection) {
          dsvSection.style.display = 'block';
          dsvSection.style.marginBottom = '0';
        }
        
        // Меняем заголовок
        if (headerTitle) {
          headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;Design System Validator';
        }
        
        // Скрываем badge с ошибками
        if (errorBadge) {
          errorBadge.style.display = 'none';
        }
        
        // Инициализируем обработчики для Design System Validator
        initDesignSystemValidator();
      } else if (mode === 'get-page-text') {
        // Режим получения текста со страницы
        body.classList.add('get-page-text-mode');
        
        // Скрываем основную функциональность
        mainFunctionality.forEach(el => {
          if (el) el.style.display = 'none';
        });
        
        // Скрываем другие секции
        if (nodeIdSection) {
          nodeIdSection.style.display = 'none';
        }
        
        if (svgExportSection) {
          svgExportSection.style.display = 'none';
        }
        
        if (aiDesignLintSection) {
          aiDesignLintSection.style.display = 'none';
        }
        
        if (dsvSection) {
          dsvSection.style.display = 'none';
        }
        
        if (componentPropertiesSection) {
          componentPropertiesSection.style.display = 'none';
        }
        
        // Показываем Get Page Text Section
        if (getPageTextSection) {
          getPageTextSection.style.display = 'block';
          getPageTextSection.style.marginBottom = '0';
        }
        
        // Меняем заголовок
        if (headerTitle) {
          headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;Get Page Text';
        }
        
        // Скрываем badge с ошибками
        if (errorBadge) {
          errorBadge.style.display = 'none';
        }
      } else {
        // Режим проверки иконок (по умолчанию)
        
        // Показываем основную функциональность
        mainFunctionality.forEach(el => {
          if (el) el.style.display = '';
        });
        
        // Скрываем Node ID Inspector, SVG Export, AI Design Lint и Design System Validator (через CSS)
        if (nodeIdSection) {
          nodeIdSection.style.display = 'none';
        }
        
        if (svgExportSection) {
          svgExportSection.style.display = 'none';
        }
        
        if (aiDesignLintSection) {
          aiDesignLintSection.style.display = 'none';
        }
        
        if (dsvSection) {
          dsvSection.style.display = 'none';
        }
        
        if (getPageTextSection) {
          getPageTextSection.style.display = 'none';
        }
        
        if (componentPropertiesSection) {
          componentPropertiesSection.style.display = 'none';
        }
        
        // Восстанавливаем оригинальный заголовок
        if (headerTitle) {
          headerTitle.innerHTML = 'Orbita DS&nbsp;&nbsp;✦&nbsp;&nbsp;Tools';
        }
      }
    }
    
    // Design System Validator - глобальное состояние
    let dsvValidationMode = 'all'; // local, remote, all
    let dsvCurrentReport = null;
    
    // Функция инициализации Design System Validator
    function initDesignSystemValidator() {
      // Получаем элементы
      const settingsButton = document.getElementById('dsv-settings-button');
      const settingsPanel = document.getElementById('dsv-settings-panel');
      const validateButtonMain = document.getElementById('dsv-validate-button-main');
      const modeButtons = document.querySelectorAll('.dsv-mode-button');
      const validateButton = document.getElementById('dsv-validate-button');
      
      // Новые элементы для импорта токенов
      const importTokensButton = document.getElementById('dsv-import-tokens-button');
      const tokensStatusText = document.getElementById('dsv-tokens-status-text');
      const fixAllButton = document.getElementById('dsv-fix-all-button');
      
      // Элементы для JSON управления
      const tokensJsonTextarea = document.getElementById('dsv-tokens-json-textarea');
      const copyJsonButton = document.getElementById('dsv-copy-json-button');
      
      // Обработчик кнопки импорта токенов
      if (importTokensButton) {
        importTokensButton.addEventListener('click', () => {
          debugLog('DSV: Запрос импорта токенов');
          
          // Показываем статус загрузки
          if (tokensStatusText) {
            tokensStatusText.textContent = 'Импортирую токены...';
            importTokensButton.disabled = true;
          }
          
          // Отправляем запрос на импорт
          parent.postMessage({
            pluginMessage: {
              type: 'dsv-import-tokens'
            }
          }, '*');
        });
      }
      
      // Обработчик кнопки копирования JSON
      if (copyJsonButton && tokensJsonTextarea) {
        copyJsonButton.addEventListener('click', () => {
          tokensJsonTextarea.select();
          document.execCommand('copy');
          
          const originalText = copyJsonButton.textContent;
          copyJsonButton.textContent = '✅ Скопировано!';
          setTimeout(() => {
            copyJsonButton.textContent = originalText;
          }, 2000);
        });
      }
      
      // Обработчик кнопки "Исправить все"
      if (fixAllButton) {
        fixAllButton.addEventListener('click', () => {
          if (!dsvCurrentReport || !dsvCurrentReport.issues) {
            return;
          }
          
          // Фильтруем только проблемы, которые можно исправить (с suggestedToken)
          const fixableIssues = dsvCurrentReport.issues.filter(issue => issue.suggestedToken);
          
          if (fixableIssues.length === 0) {
            alert('Нет проблем, которые можно исправить автоматически');
            return;
          }
          
          if (confirm(`Исправить ${fixableIssues.length} проблем автоматически?`)) {
            debugLog(`DSV: Запрос автоисправления ${fixableIssues.length} проблем`);
            
            // Показываем индикатор загрузки
            fixAllButton.disabled = true;
            fixAllButton.textContent = 'Исправляю...';
            
            // Отправляем запрос на автоисправление
            parent.postMessage({
              pluginMessage: {
                type: 'dsv-fix-all',
                issues: fixableIssues
              }
            }, '*');
          }
        });
      }
      
      // Обработчик кнопки настроек
      if (settingsButton && settingsPanel) {
        settingsButton.addEventListener('click', () => {
          const isHidden = settingsPanel.style.display === 'none';
          settingsPanel.style.display = isHidden ? 'block' : 'none';
          settingsButton.textContent = isHidden ? 'Закрыть настройки' : 'Настройки';
        });
      }
      
      // Обработчик главной кнопки "Проверить"
      if (validateButtonMain) {
        validateButtonMain.addEventListener('click', () => {
          runDSVValidation();
        });
      }
      
      // Обработчики выбора режима
      modeButtons.forEach(button => {
        button.addEventListener('click', () => {
          // Обновляем стили кнопок
          modeButtons.forEach(btn => {
            btn.style.background = '#2A2A32';
            btn.style.border = '1px solid #505059';
          });
          button.style.background = '#F86025';
          button.style.border = 'none';
          
          // Сохраняем выбранный режим
          dsvValidationMode = button.dataset.mode;
          debugLog('Design System Validator: Выбран режим', dsvValidationMode);
        });
      });
      
      // Обработчик кнопки проверки (оставляем для обратной совместимости)
      if (validateButton) {
        validateButton.addEventListener('click', () => {
          runDSVValidation();
        });
      }
    }
    
    // Функция запуска валидации DSV
    function runDSVValidation() {
      debugLog('Design System Validator: Запуск проверки, режим:', dsvValidationMode);
      
      // Показываем индикатор загрузки
      const loadingIndicator = document.getElementById('dsv-loading-indicator');
      const resultsPanel = document.getElementById('dsv-results-panel');
      
      if (loadingIndicator) loadingIndicator.style.display = 'block';
      if (resultsPanel) resultsPanel.style.display = 'none';
      
      // Блокируем кнопку проверки на время выполнения
      const validateButtonMain = document.getElementById('dsv-validate-button-main');
      if (validateButtonMain) {
        validateButtonMain.disabled = true;
        validateButtonMain.textContent = 'Проверка...';
      }
      
      // Сбрасываем счётчик прогресса
      const progressCount = document.getElementById('dsv-progress-count');
      if (progressCount) progressCount.textContent = '0';
      
      // Получаем настройки
      const skipInstancesCheckbox = document.getElementById('dsv-skip-instances');
      const skipInstances = skipInstancesCheckbox ? skipInstancesCheckbox.checked : false;
      
      const filterOrbPrefixCheckbox = document.getElementById('dsv-filter-orb-prefix');
      const filterOrbPrefix = filterOrbPrefixCheckbox ? filterOrbPrefixCheckbox.checked : true;
      
      // Собираем настройки проверяемых свойств
      const propertiesToCheck = {
        fills: document.getElementById('dsv-check-fills')?.checked ?? true,
        strokes: document.getElementById('dsv-check-strokes')?.checked ?? true,
        cornerRadius: document.getElementById('dsv-check-corner-radius')?.checked ?? true,
        spacing: document.getElementById('dsv-check-spacing')?.checked ?? true,
        padding: document.getElementById('dsv-check-padding')?.checked ?? true,
        effects: document.getElementById('dsv-check-effects')?.checked ?? false,
        opacity: document.getElementById('dsv-check-opacity')?.checked ?? false,
        size: document.getElementById('dsv-check-size')?.checked ?? false
      };
      
      debugLog('DSV: Настройки проверки:', propertiesToCheck, 'filterOrbPrefix:', filterOrbPrefix);
      
      // Отправляем сообщение в плагин с опциями
      // Токены теперь хранятся в памяти плагина (code.js)
      parent.postMessage({
        pluginMessage: {
          type: 'dsv-validate',
          mode: dsvValidationMode,
          options: {
            skipInstances: skipInstances,
            filterOrbPrefix: filterOrbPrefix,
            propertiesToCheck: propertiesToCheck
          }
        }
      }, '*');
    }
    
    // Продолжение инициализации DSV (остальные обработчики)
    (function continueInitDSV() {
      // Обработчики для экспорта и загрузки JSON с токенами
      // const exportButton = document.getElementById('dsv-export-report-button'); // удалён
      const exportTokensButton = document.getElementById('dsv-export-tokens-button');
      const exportStatus = document.getElementById('dsv-export-status');
      const exportStatusText = document.getElementById('dsv-export-status-text');
      const loadTokensJsonButton = document.getElementById('dsv-load-tokens-json-button');
      const clearTokensJsonButton = document.getElementById('dsv-clear-tokens-json-button');
      const tokensJsonFileInput = document.getElementById('dsv-tokens-json-file');
      const tokensJsonStatus = document.getElementById('dsv-tokens-json-status');
      const tokensJsonStatusText = document.getElementById('dsv-tokens-json-status-text');
      
      // Обработчик экспорта токенов
      if (exportTokensButton) {
        exportTokensButton.addEventListener('click', () => {
          debugLog('Design System Validator: Запрос экспорта токенов');
          
          // Показываем статус загрузки
          if (exportStatus) {
            exportStatus.style.display = 'block';
            exportStatusText.textContent = 'Экспортирую токены...';
            exportStatusText.style.color = '#AAAAAA';
          }
          
          // Отправляем запрос на экспорт
          parent.postMessage({
            pluginMessage: {
              type: 'dsv-export-tokens'
            }
          }, '*');
        });
      }
      
      if (loadTokensJsonButton && tokensJsonFileInput) {
        loadTokensJsonButton.addEventListener('click', () => {
          tokensJsonFileInput.click();
        });
        
        tokensJsonFileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const jsonData = JSON.parse(event.target.result);
              debugLog('Design System Validator: JSON загружен', jsonData);
              
              // Валидация JSON
              if (!jsonData.tokens || !Array.isArray(jsonData.tokens)) {
                throw new Error('JSON должен содержать массив "tokens"');
              }
              
              // Отправляем токены в code.js для хранения
              parent.postMessage({
                pluginMessage: {
                  type: 'dsv-save-tokens',
                  tokens: jsonData.tokens
                }
              }, '*');
              
              // Показываем статус загрузки
              if (tokensJsonStatus) {
                tokensJsonStatus.style.display = 'block';
                tokensJsonStatusText.textContent = 'Загружаю токены...';
                tokensJsonStatusText.style.color = '#AAAAAA';
              }
              
              debugLog('Design System Validator: Токены отправлены в плагин');
            } catch (error) {
              debugError('Design System Validator: Ошибка парсинга JSON', error);
              if (tokensJsonStatus) {
                tokensJsonStatus.style.display = 'block';
                tokensJsonStatusText.textContent = `Ошибка: ${error.message}`;
                tokensJsonStatusText.style.color = '#F44336';
              }
            }
          };
          reader.readAsText(file);
        });
      }
      
      if (clearTokensJsonButton) {
        clearTokensJsonButton.addEventListener('click', () => {
          // Открываем диалог выбора файла для замены токенов
          if (tokensJsonFileInput) {
            tokensJsonFileInput.click();
          }
          
          debugLog('Design System Validator: Открыт диалог замены токенов');
        });
      }
      
      // Запрашиваем у плагина, есть ли сохранённые токены
      parent.postMessage({
        pluginMessage: {
          type: 'dsv-get-tokens-status'
        }
      }, '*');
      
      // Обработчик для показа формата JSON
      const showJsonFormatLink = document.getElementById('dsv-show-json-format');
      if (showJsonFormatLink) {
        showJsonFormatLink.addEventListener('click', (e) => {
          e.preventDefault();
          
          const formatExample = `{
  "tokens": [
    {
      "name": "color/primary/500",
      "type": "COLOR",
      "value": "#F86025",
      "isRemote": true
    },
    {
      "name": "spacing/md",
      "type": "FLOAT",
      "value": 16,
      "isRemote": true
    }
  ]
}`;
          
          const message = `📋 ФОРМАТ JSON ДЛЯ ТОКЕНОВ\n\n` +
            `Обязательное поле:\n` +
            `• name - имя токена (строка)\n\n` +
            `Опциональные поля:\n` +
            `• type - тип токена (COLOR, FLOAT, STRING)\n` +
            `• value - значение токена\n` +
            `• isRemote - токен из библиотеки (true/false)\n` +
            `• description - описание\n\n` +
            `Пример:\n${formatExample}\n\n` +
            `📖 Подробная документация: DSV_JSON_TOKENS_GUIDE.md\n` +
            `📦 Пример файла: tokens-example.json\n` +
            `🔧 Скрипт экспорта: export-tokens-script.js`;
          
          alert(message);
        });
      }
      
      // Обработчики для кнопок управления чекбоксами свойств
      const selectAllPropsBtn = document.getElementById('dsv-select-all-props');
      const selectNonePropsBtn = document.getElementById('dsv-select-none-props');
      const selectDefaultPropsBtn = document.getElementById('dsv-select-default-props');
      
      const propertyCheckboxes = [
        'dsv-check-fills',
        'dsv-check-strokes',
        'dsv-check-corner-radius',
        'dsv-check-spacing',
        'dsv-check-padding',
        'dsv-check-effects',
        'dsv-check-opacity',
        'dsv-check-size'
      ];
      
      // По умолчанию включены: fills, strokes, corner-radius, spacing, padding
      const defaultEnabled = [
        'dsv-check-fills',
        'dsv-check-strokes',
        'dsv-check-corner-radius',
        'dsv-check-spacing',
        'dsv-check-padding'
      ];
      
      if (selectAllPropsBtn) {
        selectAllPropsBtn.addEventListener('click', () => {
          propertyCheckboxes.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) checkbox.checked = true;
          });
          debugLog('DSV: Выбраны все свойства');
        });
      }
      
      if (selectNonePropsBtn) {
        selectNonePropsBtn.addEventListener('click', () => {
          propertyCheckboxes.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) checkbox.checked = false;
          });
          debugLog('DSV: Отключены все свойства');
        });
      }
      
      if (selectDefaultPropsBtn) {
        selectDefaultPropsBtn.addEventListener('click', () => {
          propertyCheckboxes.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
              checkbox.checked = defaultEnabled.includes(id);
            }
          });
          debugLog('DSV: Установлены свойства по умолчанию');
        });
      }
      
      debugLog('Design System Validator: Инициализация завершена');
    })(); // Закрытие continueInitDSV и немедленный вызов
    
    // Функция отображения результатов проверки
    function displayDSVResults(report) {
      debugLog('Design System Validator: Отображение результатов', report);
      
      // Скрываем индикатор загрузки
      const loadingIndicator = document.getElementById('dsv-loading-indicator');
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      
      // Показываем панель результатов
      const resultsPanel = document.getElementById('dsv-results-panel');
      if (resultsPanel) resultsPanel.style.display = 'block';
      
      // Сохраняем отчёт
      dsvCurrentReport = report;
      
      // Обновляем сводку
      const totalNodesEl = document.getElementById('dsv-total-nodes');
      if (totalNodesEl) totalNodesEl.textContent = report.totalNodes || 0;
      
      const totalIssuesEl = document.getElementById('dsv-total-issues');
      if (totalIssuesEl) totalIssuesEl.textContent = report.totalIssues || 0;
      
      // Отображаем список проблем
      const issuesSection = document.getElementById('dsv-issues-section');
      const issuesList = document.getElementById('dsv-issues-list');
      const fixAllButton = document.getElementById('dsv-fix-all-button');
      
      if (report.issues && report.issues.length > 0) {
        if (issuesSection) issuesSection.style.display = 'block';
        if (issuesList) {
          issuesList.innerHTML = '';
          
          report.issues.forEach((issue, index) => {
            const issueCard = createDSVIssueCard(issue, index);
            issuesList.appendChild(issueCard);
          });
        }
        
        // Показываем кнопку "Fix All" если есть исправляемые проблемы
        const fixableIssues = report.issues.filter(issue => issue.suggestedToken);
        if (fixAllButton && fixableIssues.length > 0) {
          fixAllButton.style.display = 'inline-block';
          fixAllButton.textContent = `🔧 Исправить все (${fixableIssues.length})`;
        } else if (fixAllButton) {
          fixAllButton.style.display = 'none';
        }
      } else {
        if (issuesSection) issuesSection.style.display = 'none';
        if (fixAllButton) fixAllButton.style.display = 'none';
      }
    }
    
    // Функция создания карточки проблемы
    function createDSVIssueCard(issue, issueIndex) {
      const card = document.createElement('div');
      card.style.cssText = 'background: #44444C; border-radius: 8px; padding: 12px; margin-bottom: 8px; border-left: 3px solid ' + 
        (issue.severity === 'high' ? '#F44336' : issue.severity === 'medium' ? '#FF9800' : '#FFC107') + '; cursor: pointer; transition: all 0.2s;';
      
      card.addEventListener('mouseenter', () => {
        card.style.background = '#505059';
      });
      
      card.addEventListener('mouseleave', () => {
        card.style.background = '#44444C';
      });
      
      // Кликабельность для перехода к элементу
      const cardClickHandler = (e) => {
        // Не переходим если клик был по кнопке
        if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
          return;
        }
        if (issue.nodeId) {
          parent.postMessage({
            pluginMessage: {
              type: 'dsv-focus-node',
              nodeId: issue.nodeId
            }
          }, '*');
        }
      };
      card.addEventListener('click', cardClickHandler);
      
      // Заголовок с типом проблемы
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;';
      
      const typeLabel = document.createElement('span');
      typeLabel.style.cssText = 'font-size: 10px; font-weight: 600; padding: 3px 8px; border-radius: 4px; background: #2A2A32; color: #F86025; text-transform: uppercase;';
      typeLabel.textContent = issue.type || 'Issue';
      
      const nodeLabel = document.createElement('span');
      nodeLabel.style.cssText = 'font-size: 10px; color: #AAAAAA; font-family: "SF Mono", Monaco, monospace;';
      nodeLabel.textContent = '→ ' + (issue.nodeName || 'Unknown');
      
      header.appendChild(typeLabel);
      header.appendChild(nodeLabel);
      
      // Описание проблемы
      const description = document.createElement('div');
      description.style.cssText = 'font-size: 12px; line-height: 1.5; color: #FFFFFF; margin-bottom: 4px;';
      description.textContent = issue.description || 'No description';
      
      // Дополнительная информация (если есть)
      if (issue.property) {
        const propertyLabel = document.createElement('div');
        propertyLabel.style.cssText = 'font-size: 11px; color: #AAAAAA; margin-top: 4px;';
        propertyLabel.textContent = `Property: ${issue.property}`;
        description.appendChild(propertyLabel);
      }
      
      card.appendChild(header);
      card.appendChild(description);
      
      // Если есть предложенный токен - показываем его и кнопку
      if (issue.suggestedToken) {
        console.log('🔍 DEBUG UI: Показываем кнопку для', issue.property, 'токен:', issue.suggestedToken);
        
        const tokenSuggestion = document.createElement('div');
        tokenSuggestion.style.cssText = 'margin-top: 8px; padding: 8px; background: rgba(76, 175, 80, 0.1); border-radius: 6px; border: 1px solid rgba(76, 175, 80, 0.3);';
        
        const suggestionLabel = document.createElement('div');
        suggestionLabel.style.cssText = 'font-size: 10px; color: #4CAF50; font-weight: 600; margin-bottom: 4px; text-transform: uppercase;';
        suggestionLabel.textContent = 'Найден подходящий токен';
        
        const tokenInfo = document.createElement('div');
        tokenInfo.style.cssText = 'font-size: 11px; color: #FFFFFF; margin-bottom: 6px;';
        tokenInfo.textContent = `${issue.suggestedToken.name} = ${formatTokenValue(issue.suggestedToken.value)}`;
        
        const bindButton = document.createElement('button');
        bindButton.style.cssText = 'padding: 6px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: pointer; transition: background 0.2s;';
        bindButton.textContent = '🔗 Привязать токен';
        bindButton.dataset.issueIndex = issueIndex;
        
        bindButton.addEventListener('mouseenter', () => {
          bindButton.style.background = '#45a049';
        });
        
        bindButton.addEventListener('mouseleave', () => {
          bindButton.style.background = '#4CAF50';
        });
        
        bindButton.addEventListener('click', (e) => {
          e.stopPropagation(); // Предотвращаем переход к элементу
          bindTokenToIssue(issue, issueIndex, bindButton);
        });
        
        tokenSuggestion.appendChild(suggestionLabel);
        tokenSuggestion.appendChild(tokenInfo);
        tokenSuggestion.appendChild(bindButton);
        
        card.appendChild(tokenSuggestion);
      }
      
      return card;
    }
    
    // Вспомогательная функция для форматирования значения токена
    function formatTokenValue(value) {
      if (typeof value === 'number') {
        return value;
      } else if (typeof value === 'object' && value.r !== undefined) {
        // Цвет в формате RGB
        const r = Math.round(value.r * 255);
        const g = Math.round(value.g * 255);
        const b = Math.round(value.b * 255);
        return `rgb(${r}, ${g}, ${b})`;
      } else if (typeof value === 'string') {
        return value;
      }
      return JSON.stringify(value);
    }
    
    // Функция привязки токена к элементу
    function bindTokenToIssue(issue, issueIndex, button) {
      if (!issue.suggestedToken) return;
      
      // Отключаем кнопку и меняем текст
      button.disabled = true;
      button.textContent = 'Привязка...';
      button.style.background = '#999';
      
      // Отправляем запрос на привязку токена
      parent.postMessage({
        pluginMessage: {
          type: 'dsv-bind-token',
          nodeId: issue.nodeId,
          property: mapPropertyDisplayToKey(issue.property),
          tokenId: issue.suggestedToken.id,
          issueIndex: issueIndex
        }
      }, '*');
    }
    
    // Функция маппинга отображаемого имени свойства к ключу API
    function mapPropertyDisplayToKey(displayName) {
      const mapping = {
        'Fill': 'fills',
        'Stroke': 'strokes',
        'Corner Radius': 'cornerRadius',
        'Padding Left': 'paddingLeft',
        'Padding Right': 'paddingRight',
        'Padding Top': 'paddingTop',
        'Padding Bottom': 'paddingBottom',
        'Gap': 'itemSpacing',
        'Effect': 'effects',
        'Opacity': 'opacity',
        'Width': 'width',
        'Height': 'height'
      };
      
      // Если это угол с постфиксом (например "Corner Radius Top-Left")
      if (displayName.startsWith('Corner Radius ')) {
        const cornerPart = displayName.replace('Corner Radius ', '').replace('-', '');
        if (cornerPart === 'TopLeft') return 'topLeftRadius';
        if (cornerPart === 'TopRight') return 'topRightRadius';
        if (cornerPart === 'BottomLeft') return 'bottomLeftRadius';
        if (cornerPart === 'BottomRight') return 'bottomRightRadius';
      }
      
      return mapping[displayName] || displayName.toLowerCase();
    }
    
    // Обработчик сообщений от плагина
    window.onmessage = (event) => {
      // Проверяем, что есть данные и pluginMessage
      if (!event || !event.data || !event.data.pluginMessage) {
        return; // Игнорируем сообщения не от плагина
      }
      
      const message = event.data.pluginMessage;
      
      // Проверяем что message существует и имеет type
      if (!message || !message.type) {
        debugWarn('Получено сообщение без типа:', message);
        return;
      }
      
      // Логируем все сообщения для отладки
      if (message.type === 'markdown-export-progress' || message.type === 'markdown-export-result') {
        console.log('Получено сообщение от плагина:', message.type, message);
      }
      
      if (message.type === 'set-mode') {
        // Настройка UI в зависимости от режима
        setupUIMode(message.mode);
      } else if (message.type === 'saved-selection') {
        // Сохраняем выделение, которое было при запуске проверки
        savedSelection = message.nodeIds;
        console.log('Сохранено выделение:', savedSelection);
      } else if (message.type === 'progress') {
        // Обновляем индикатор прогресса (для обычной проверки иконок)
        displayMessage({
          type: 'progress',
          message: message.message,
          percent: message.percent
        });
        
        // Если прогресс достиг 100%, сбрасываем флаг проверки и возвращаем кнопке исходный вид
        if (message.percent === 100) {
          isCheckingInProgress = false;
          checkButton.textContent = 'Проверить';
          checkButton.style.backgroundColor = '#F86025';
        }
        
        // Обновляем прогресс для экспорта свойств компонентов
        const componentProgress = document.getElementById('component-properties-progress');
        const componentProgressFill = document.getElementById('component-properties-progress-fill');
        const componentProgressText = document.getElementById('component-properties-progress-text');
        const componentCounter = document.getElementById('component-properties-counter');
        const componentPercentage = document.getElementById('component-properties-percentage');
        const componentCurrentItem = document.getElementById('component-properties-current-item');
        
        if (componentProgress && componentProgressFill && componentProgressText) {
          componentProgressFill.style.width = message.percent + '%';
          componentProgressText.textContent = message.message;
          
          // Обновляем счетчик если есть
          if (componentCounter && message.current !== undefined && message.total !== undefined) {
            componentCounter.textContent = `${message.current}/${message.total}`;
          }
          
          // Обновляем процент
          if (componentPercentage) {
            componentPercentage.textContent = `${Math.round(message.percent)}%`;
          }
          
          // Обновляем текущий элемент
          if (componentCurrentItem && message.currentItem) {
            componentCurrentItem.textContent = message.currentItem;
          }
        }
      } else if (message.type === 'svg-export-progress') {
        // Детальный прогресс для SVG экспорта
        debugLog('SVG Export: Получен прогресс экспорта:', message);
        
        if (svgExportProgress.style.display !== 'none') {
          const currentTime = Date.now();
          
          // Обновляем счетчик
          exportCounter.textContent = `${message.current}/${message.total}`;
          
          // Обновляем процент
          const percent = Math.round((message.current / message.total) * 100);
          exportPercentage.textContent = `${percent}%`;
          
          // Обновляем прогрессбар
          exportProgressFill.style.width = `${percent}%`;
          
          // Обновляем текущую иконку
          if (message.currentIcon) {
            exportCurrentIcon.textContent = message.currentIcon;
          }
          
          // Обновляем основной текст
          if (message.message) {
            exportProgressText.textContent = message.message;
          }
          
          // Рассчитываем скорость и время
          if (exportStartTime && message.current > 0) {
            const elapsedSeconds = Math.floor((currentTime - exportStartTime) / 1000);
            const processedCount = message.current;
            
            // Обновляем прошедшее время
            exportElapsedTime.textContent = `Время: ${elapsedSeconds}с`;
            
            // Рассчитываем скорость (иконок в секунду)
            if (elapsedSeconds > 0) {
              const speed = (processedCount / elapsedSeconds).toFixed(1);
              exportSpeed.textContent = `${speed} иконок/сек`;
              
              // Рассчитываем оставшееся время
              if (processedCount > 0 && message.total > processedCount) {
                const remainingCount = message.total - processedCount;
                const estimatedRemainingSeconds = Math.ceil(remainingCount / (processedCount / elapsedSeconds));
                exportRemainingTime.textContent = `Осталось: ~${estimatedRemainingSeconds}с`;
              }
            }
          }
        }
      } else if (message.type === 'all-text-result') {
        // Обработка результата получения текста со страницы
        const textOutputContainer = document.getElementById('text-output-container');
        const textTotalNodes = document.getElementById('text-total-nodes');
        const textTotalChars = document.getElementById('text-total-chars');
        const textStatsSection = document.getElementById('text-stats-section');
        const textActionsSection = document.getElementById('text-actions-section');
        const textLoadingIndicator = document.getElementById('text-loading-indicator');
        
        if (message.success && message.data) {
          const data = message.data;
          currentText = data.allText;
          
          // Скрываем индикатор загрузки
          if (textLoadingIndicator) textLoadingIndicator.style.display = 'none';
          
          // Обновляем статистику
          if (textTotalNodes) textTotalNodes.textContent = data.totalNodes || 0;
          if (textTotalChars) textTotalChars.textContent = (data.statistics && data.statistics.totalCharacters) || 0;
          
          // Показываем статистику
          if (textStatsSection) textStatsSection.style.display = 'block';
          
          // Выводим текст
          if (textOutputContainer) {
            textOutputContainer.textContent = currentText || 'Текст не найден на странице';
            textOutputContainer.style.display = 'block';
          }
          
          // Показываем кнопки действий
          if (textActionsSection) textActionsSection.style.display = 'flex';
        } else {
          // Обработка ошибки
          if (textLoadingIndicator) textLoadingIndicator.style.display = 'none';
          
          if (textOutputContainer) {
            textOutputContainer.textContent = `Ошибка: ${message.error || 'Не удалось получить текст'}`;
            textOutputContainer.style.display = 'block';
          }
        }
      } else if (message.type === 'markdown-export-progress') {
        // Обновление прогресса экспорта в Markdown
        const markdownExportProgress = document.getElementById('markdown-export-progress');
        const progressText = document.getElementById('markdown-progress-text');
        const progressBar = document.getElementById('markdown-progress-bar');
        
        if (markdownExportProgress) markdownExportProgress.style.display = 'block';
        if (progressText && message.message) {
          progressText.textContent = message.message;
        }
        if (progressBar && message.percent !== undefined) {
          progressBar.style.width = message.percent + '%';
        }
      } else if (message.type === 'markdown-export-result') {
        // Результат экспорта в Markdown
        console.log('Получен результат экспорта в Markdown:', message);
        
        const markdownExportProgress = document.getElementById('markdown-export-progress');
        const progressText = document.getElementById('markdown-progress-text');
        const progressBar = document.getElementById('markdown-progress-bar');
        
        // НЕ скрываем прогресс сразу - покажем статус результата
        if (progressBar) progressBar.style.width = '100%';
        
        if (message.success && message.data) {
          const { markdown, json, images, pageName } = message.data;
          console.log('Данные экспорта:', { 
            markdownLength: (markdown && markdown.length) || 0, 
            jsonLength: (json && json.length) || 0,
            imagesCount: (images && images.length) || 0, 
            pageName 
          });
          
          // Создаем ZIP архив с Markdown, JSON файлами и изображениями
          if (typeof JSZip !== 'undefined') {
            console.log('JSZip доступен, создаем архив');
            try {
              const zip = new JSZip();
              
              // Добавляем Markdown файл
              if (markdown) {
                zip.file(`${pageName || 'page'}.md`, markdown);
              }
              
              // Добавляем JSON файл
              if (json) {
                zip.file(`${pageName || 'page'}.json`, json);
              }
              
              // Создаем папку для изображений
              const assetsFolder = zip.folder('figma-assets');
              
              // Добавляем изображения
              for (const image of images) {
                if (image.data && image.filename) {
                  const imageData = new Uint8Array(image.data);
                  const filename = image.filename.includes('/') 
                    ? image.filename.split('/').pop() 
                    : image.filename;
                  assetsFolder.file(filename, imageData);
                }
              }
              
              // Генерируем и скачиваем ZIP
              zip.generateAsync({ type: 'blob' }).then((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const safePageName = (pageName || 'figma-export').replace(/[^a-zA-Z0-9-_]/g, '-');
                a.download = `${safePageName}-${new Date().toISOString().slice(0, 10)}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Уведомление об успехе
                const progressText = document.getElementById('markdown-progress-text');
                if (progressText) {
                  progressText.textContent = 'Экспорт завершен!';
                  progressText.style.color = '#4CAF50';
                  setTimeout(() => {
                    if (markdownExportProgress) markdownExportProgress.style.display = 'none';
                  }, 2000);
                }
              }).catch(err => {
                console.error('Ошибка при создании ZIP:', err);
                alert('Ошибка при создании ZIP архива');
              });
            } catch (error) {
              console.error('Ошибка при экспорте в Markdown:', error);
              alert(`Ошибка: ${error.message || 'Не удалось создать архив'}`);
            }
          } else {
            console.warn('JSZip недоступен, используем fallback');
            // Fallback: просто скачиваем Markdown (если JSZip недоступен)
            const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const safePageName = (pageName || 'page').replace(/[^a-zA-Z0-9-_]/g, '-');
            a.download = `${safePageName}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            if (progressText) {
              progressText.textContent = 'Markdown скачан (без изображений)';
              progressText.style.color = '#4CAF50';
            }
            setTimeout(() => {
              if (markdownExportProgress) markdownExportProgress.style.display = 'none';
            }, 2000);
          }
        } else {
          // Обработка ошибки
          console.error('Ошибка экспорта:', message.error);
          const errorMessage = message.error || 'Неизвестная ошибка';
          alert(`Ошибка экспорта: ${errorMessage}`);
          
          if (markdownExportProgress) markdownExportProgress.style.display = 'block';
          const progressText = document.getElementById('markdown-progress-text');
          if (progressText) {
            progressText.textContent = 'Ошибка: ' + errorMessage;
            progressText.style.color = '#F44336';
          }
        }
      } else if (message.type === 'error') {
        // Отображаем ошибку
        displayMessage({
          type: 'error',
          message: message.message
        });
        
        // Скрываем статус загрузки и прогресс
        statusElement.style.display = 'none';
        progressContainer.style.display = 'none';
        
        // Сбрасываем флаг проверки и возвращаем кнопке исходный вид
        isCheckingInProgress = false;
        checkButton.textContent = 'Проверить';
        checkButton.style.backgroundColor = '#F86025';
      } else if (message.type === 'create-cell-result') {
        // Отображаем результат создания Cell
        if (message.result.success) {
          displayMessage({
            type: 'success',
            message: message.result.message
          });
        } else {
          displayMessage({
            type: 'error',
            message: message.result.message
          });
        }
      } else if (message.type === 'check-results') {
        // Скрываем статус загрузки и прогресс
        statusElement.style.display = 'none';
        progressContainer.style.display = 'none';
        
        // Сохраняем результаты
        currentResults = message.results;
        
        // Отображаем результаты проверки и обновляем счетчик ошибок
        displayResults(message.results);
        
        // Сбрасываем флаг проверки и возвращаем кнопке исходный вид
        isCheckingInProgress = false;
        checkButton.textContent = 'Проверить';
        checkButton.style.backgroundColor = '#F86025';
        
        // Дополнительно обновляем счетчик ошибок для уверенности
        setTimeout(function() {
          if (message.results.length === 0) {
            // Скрываем счетчик ошибок, если ошибок нет
            errorBadge.style.display = 'none';
          } else {
            // Подсчитываем общее количество ошибок
            let totalErrors = 0;
            message.results.forEach(result => {
              totalErrors += result.errors.length;
            });
            
            // Показываем счетчик ошибок только если есть ошибки
            if (totalErrors > 0) {
              errorBadge.textContent = totalErrors;
              errorBadge.style.display = 'inline-flex';
              errorBadge.classList.add('animate-pulse');
            } else {
              errorBadge.style.display = 'none';
            }
          }
        }, 100);
      } else if (message.type === 'fix-result') {
        // Обновляем UI после исправления ошибки
        if (message.result.success) {
          displayMessage({
            type: 'success',
            message: message.result.message
          });
          
          // Восстанавливаем исходное выделение и запускаем проверку
          if (savedSelection && savedSelection.length > 0) {
            parent.postMessage({
              pluginMessage: {
                type: 'restore-selection',
                nodeIds: savedSelection
              }
            }, '*');
            
            // Небольшая задержка перед запуском проверки, чтобы выделение успело восстановиться
            setTimeout(() => {
              checkButton.click();
            }, 100);
          } else {
            // Если нет сохраненного выделения, просто запускаем проверку
            checkButton.click();
          }
        } else {
          displayMessage({
            type: 'error',
            message: message.result.message
          });
        }
      } else if (message.type === 'fix-all-result') {
        // Скрываем статус загрузки и прогресс
        statusElement.style.display = 'none';
        progressContainer.style.display = 'none';
        
        // Отображаем результат исправления всех ошибок
        if (message.result.success) {
          displayMessage({
            type: 'success',
            message: message.result.message
          });
          
          // Запускаем повторную проверку
          checkButton.click();
        } else {
          displayMessage({
            type: 'error',
            message: message.result.message
          });
        }
      } else if (message.type === 'settings') {
        // Обновляем чекбоксы в соответствии с настройками
        for (const [key, value] of Object.entries(message.settings)) {
          if (checkboxes[key]) {
            checkboxes[key].checked = value;
          }
        }
        // Обновляем состояние чекбоксов с учетом зависимостей
        updateCheckboxStates();
      } else if (message.type === 'settings-updated') {
        // Обработка подтверждения обновления настроек
        debugLog('Настройки обновлены:', message.settings);
      } else if (message.type === 'selected-node-id') {
        // Обработка получения ID выделенного объекта
        if (message.success) {
          const nodeId = message.nodeId;
          const nodeName = message.nodeName || 'Неизвестный объект';
          
          // Обновляем отображение текущего ID
          currentNodeIdDisplay.textContent = `ID: ${nodeId} (${nodeName})`;
          
          // Добавляем ID в textarea
          const currentText = nodeIdsTextarea.value;
          const newLine = currentText ? '\n' : '';
          nodeIdsTextarea.value = currentText + newLine + nodeId;
          
          // Показываем сообщение об успехе
          displayMessage({
            type: 'success',
            message: `ID получен: ${nodeName}`
          });
        } else {
          // Показываем ошибку
          displayMessage({
            type: 'error',
            message: message.message || 'Не удалось получить ID выделенного объекта'
          });
        }
      } else if (message.type === 'scan-result') {
        // Обработка результата сканирования иконок
        debugLog('SVG Export: Получен результат сканирования:', message.result);
        
        // Возвращаем кнопке исходный вид
        scanIconsButton.textContent = 'Пересчитать иконки';
        scanIconsButton.disabled = false;
        
        if (message.result.success) {
          // Сохраняем данные сканирования
          scannedComponentSets = message.result.componentSets;
          debugLog('SVG Export: Сохранены данные компонент-сетов:', scannedComponentSets);
          
          // Обновляем статистику
          componentSetsCount.textContent = message.result.componentSetsCount;
          totalVariantsCount.textContent = message.result.totalVariants;
          
          // Показываем статистику и кнопку экспорта
          if (message.result.componentSetsCount > 0) {
            exportStats.style.display = 'block';
            colorOptions.style.display = 'block';
            exportIconsButton.style.display = 'block';
            exportInfo.style.display = 'block';
            
            // Проверяем и обновляем информацию о способе загрузки
            const downloadMethodInfo = document.getElementById('download-method-info');
            if (downloadMethodInfo) {
              if (typeof JSZip !== 'undefined') {
                downloadMethodInfo.textContent = '💾 Скачается один ZIP файл со всеми иконками';
                downloadMethodInfo.style.color = '#4CAF50';
              } else {
                downloadMethodInfo.textContent = '📁 Файлы будут скачаны по отдельности (резервный режим)';
                downloadMethodInfo.style.color = '#2196F3';
              }
            }
            
            displayMessage({
              type: 'success',
              message: `Найдено ${message.result.componentSetsCount} компонент-сетов с ${message.result.totalVariants} вариантами`
            });
          } else {
            exportStats.style.display = 'none';
            colorOptions.style.display = 'none';
            exportIconsButton.style.display = 'none';
            exportInfo.style.display = 'none';
            
            displayMessage({
              type: 'error',
              message: 'На странице не найдено компонент-сетов с префиксом "orb-icon-"'
            });
          }
        } else {
          debugLog('SVG Export: Ошибка сканирования:', message.result.message);
          displayMessage({
            type: 'error',
            message: message.result.message || 'Ошибка при сканировании иконок'
          });
        }
      } else if (message.type === 'export-result') {
        // Обработка результата экспорта
        debugLog('SVG Export: Получен результат экспорта:', message.result);
        
        // Возвращаем кнопке исходный вид
        exportIconsButton.textContent = 'Экспортировать в SVG (zip)';
        exportIconsButton.disabled = false;
        
        // Скрываем детальный прогрессбар SVG экспорта
        svgExportProgress.style.display = 'none';
        
        // Сбрасываем переменные времени
        exportStartTime = null;
        lastUpdateTime = null;
        lastProcessedCount = 0;
      } else if (message.type === 'save-svg-file') {
        // Обработка сохранения SVG файла - добавляем в архив
        debugLog('SVG Export: Получен файл для добавления в архив:', message.fileName);
        
        try {
          // Добавляем файл в массив для архива
          svgFiles.push({
            name: message.fileName,
            data: message.svgData
          });
          
          debugLog(`SVG Export: Добавлен файл в архив (${svgFiles.length}/${expectedFilesCount}):`, message.fileName);
          
          // Если получили все файлы, создаем ZIP архив
          if (svgFiles.length >= expectedFilesCount) {
            debugLog('SVG Export: Все файлы получены, создаем ZIP архив...');
            createAndDownloadZip().catch(error => {
              console.error('SVG Export: Ошибка при создании ZIP архива:', error);
              displayMessage({
                type: 'error',
                message: `Ошибка при создании архива: ${error.message}`
              });
            });
          }
        } catch (error) {
          console.error('SVG Export: Ошибка при добавлении файла в архив:', message.fileName, error);
        }
      } else if (message.type === 'design-info-collected') {
        // AI Design Lint - обработка собранной информации о дизайне
        debugLog('AI Design Lint: Получена информация о дизайне:', message.designInfo);
        
        if (!message.designInfo.success) {
          if (aiAnalysisResult) {
            aiAnalysisResult.innerHTML = `<p style="color: #F02D2D;">${message.designInfo.message}</p>`;
          }
          if (analyzeDesignButton) {
            analyzeDesignButton.textContent = 'Анализировать дизайн';
            analyzeDesignButton.disabled = false;
          }
          return;
        }
        
        // Сохраняем designInfo для использования при отображении
        window.currentDesignInfo = message.designInfo;
        
        // Обновляем индикатор загрузки
        if (aiAnalysisResult) {
          aiAnalysisResult.innerHTML = '<div class="ai-loading">Отправляем запрос к AI</div>';
        }
        
        // Отправляем запрос к Eliza API
        const token = yandexTokenInput ? yandexTokenInput.value.trim() : '';
        const userPrompt = aiPromptInput ? aiPromptInput.value.trim() : '';
        
        sendToElizaAPI(message.designInfo, userPrompt, token)
          .then(result => {
            if (analyzeDesignButton) {
              analyzeDesignButton.textContent = 'Анализировать дизайн';
              analyzeDesignButton.disabled = false;
            }
            
            if (result.success) {
              displayAIAnalysis(result.analysis, window.currentDesignInfo);
            } else {
              if (aiAnalysisResult) {
                aiAnalysisResult.innerHTML = `<p style="color: #F02D2D;">Ошибка: ${result.error}</p>`;
              }
            }
          })
          .catch(error => {
            console.error('Ошибка при запросе к Eliza API:', error);
            if (analyzeDesignButton) {
              analyzeDesignButton.textContent = 'Анализировать дизайн';
              analyzeDesignButton.disabled = false;
            }
            if (aiAnalysisResult) {
              aiAnalysisResult.innerHTML = `<p style="color: #F02D2D;">Ошибка при запросе к API: ${error.message}</p>`;
            }
          });
      } else if (message.type === 'ai-lint-progress') {
        // AI Design Lint - обновление прогресса
        if (aiAnalysisResult) {
          aiAnalysisResult.innerHTML = `<div class="ai-loading">${message.message}</div>`;
        }
      } else if (message.type === 'saved-token') {
        // AI Design Lint - получен сохраненный токен
        if (message.token && yandexTokenInput) {
          yandexTokenInput.value = message.token;
        }
      } else if (message.type === 'token-saved') {
        // AI Design Lint - токен успешно сохранен
        debugLog('AI Design Lint: Токен успешно сохранен');
      } else if (message.type === 'custom-design-system-loaded') {
        // AI Design Lint - загружена кастомная дизайн-система
        if (message.data) {
          customDesignSystemJson = message.data;
          updateJsonStatus('design-system.json', true);
          debugLog('AI Design Lint: Кастомная дизайн-система загружена из хранилища');
        }
      } else if (message.type === 'dsv-validation-result') {
        // Design System Validator - результаты проверки
        debugLog('Design System Validator: Получены результаты проверки', message.report);
        
        // DEBUG: Проверяем suggestedToken в первой проблеме
        if (message.report.issues && message.report.issues.length > 0) {
          console.log('🔍 DEBUG UI: Первая проблема:', {
            type: message.report.issues[0].type,
            property: message.report.issues[0].property,
            value: message.report.issues[0].value,
            hasSuggestedToken: !!message.report.issues[0].suggestedToken,
            suggestedToken: message.report.issues[0].suggestedToken
          });
        }
        
        displayDSVResults(message.report);
      } else if (message.type === 'dsv-validation-progress') {
        // Design System Validator - обновление прогресса
        const progressCount = document.getElementById('dsv-progress-count');
        if (progressCount) {
          progressCount.textContent = message.processed || 0;
        }
        debugLog('Design System Validator: Прогресс проверки', message.processed);
      } else if (message.type === 'dsv-validation-error') {
        // Design System Validator - ошибка проверки
        debugLog('Design System Validator: Ошибка проверки', message.error);
        
        // Скрываем индикатор загрузки
        const loadingIndicator = document.getElementById('dsv-loading-indicator');
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        
        // Очищаем предыдущие результаты
        dsvCurrentReport = null;
        
        // Показываем ошибку
        const resultsPanel = document.getElementById('dsv-results-panel');
        if (resultsPanel) {
          resultsPanel.innerHTML = `<div style="background: #44444C; border-radius: 8px; padding: 16px; color: #F44336; text-align: center;">
            <div style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">Ошибка при проверке</div>
            <div style="font-size: 12px; color: #AAAAAA;">${message.error || 'Неизвестная ошибка'}</div>
          </div>`;
          resultsPanel.style.display = 'block';
        }
        
        // Разблокируем кнопку проверки
        const validateButtonMain = document.getElementById('dsv-validate-button-main');
        if (validateButtonMain) {
          validateButtonMain.disabled = false;
          validateButtonMain.textContent = 'Проверить';
        }
      } else if (message.type === 'dsv-bind-token-result') {
        // Design System Validator - результат привязки токена
        debugLog('Design System Validator: Результат привязки токена', message.result);
        
        if (message.result.success) {
          // Удаляем issue из отчета, так как токен привязан
          if (dsvCurrentReport && dsvCurrentReport.issues && message.issueIndex !== undefined) {
            dsvCurrentReport.issues.splice(message.issueIndex, 1);
            dsvCurrentReport.totalIssues = dsvCurrentReport.issues.length;
            
            // Перерисовываем результаты
            displayDSVResults(dsvCurrentReport);
          }
        } else {
          // Показываем ошибку (уже показана в уведомлении Figma)
          debugLog('Design System Validator: Ошибка при привязке токена', message.result.error);
        }
      } else if (message.type === 'dsv-export-tokens-result') {
        // Design System Validator - результат экспорта токенов
        debugLog('Design System Validator: Получены экспортированные токены', message.data);
        
        const exportStatus = document.getElementById('dsv-export-status');
        const exportStatusText = document.getElementById('dsv-export-status-text');
        
        if (message.success && message.data) {
          // Создаём JSON строку
          const jsonString = JSON.stringify(message.data, null, 2);
          
          // Автоматически скачиваем файл
          const blob = new Blob([jsonString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `design-tokens-export-${Date.now()}.json`;
          link.click();
          URL.revokeObjectURL(url);
          
          // Показываем успех
          if (exportStatus) {
            exportStatus.style.display = 'block';
            exportStatusText.textContent = `Экспортировано токенов: ${message.data.tokens.length} (файл скачан)`;
            exportStatusText.style.color = '#4CAF50';
          }
          
          debugLog('Design System Validator: Токены экспортированы и скачаны');
          
          // Автоматически скрываем статус через 5 секунд
          setTimeout(() => {
            if (exportStatus) exportStatus.style.display = 'none';
          }, 5000);
        } else {
          // Показываем ошибку
          if (exportStatus) {
            exportStatus.style.display = 'block';
            exportStatusText.textContent = `Ошибка: ${message.error || 'Не удалось экспортировать токены'}`;
            exportStatusText.style.color = '#F44336';
          }
          
          debugError('Design System Validator: Ошибка экспорта токенов', message.error);
        }
      } else if (message.type === 'dsv-tokens-saved') {
        // Design System Validator - токены успешно сохранены
        debugLog('Design System Validator: Токены сохранены в памяти плагина', message.count);
        
        const tokensJsonStatus = document.getElementById('dsv-tokens-json-status');
        const tokensJsonStatusText = document.getElementById('dsv-tokens-json-status-text');
        const clearTokensJsonButton = document.getElementById('dsv-clear-tokens-json-button');
        
        if (tokensJsonStatus && tokensJsonStatusText) {
          tokensJsonStatus.style.display = 'block';
          
          let statusText = `Загружено токенов: ${message.count}`;
          if (message.savedAt) {
            const date = new Date(message.savedAt);
            const timeStr = date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
            statusText += ` (${timeStr})`;
          }
          
          // Показываем предупреждение если токены не сохранены навсегда
          if (message.persistent === false && message.warning) {
            statusText += '\n⚠️ ' + message.warning;
            tokensJsonStatusText.style.color = '#FF9800'; // Оранжевый для предупреждения
          } else {
            tokensJsonStatusText.style.color = '#4CAF50'; // Зелёный для успеха
          }
          
          tokensJsonStatusText.textContent = statusText;
        }
        
        if (clearTokensJsonButton) {
          clearTokensJsonButton.disabled = false;
        }
      } else if (message.type === 'dsv-tokens-save-error') {
        // Design System Validator - ошибка при сохранении токенов
        debugError('Design System Validator: Ошибка сохранения токенов', message.error);
        
        const tokensJsonStatus = document.getElementById('dsv-tokens-json-status');
        const tokensJsonStatusText = document.getElementById('dsv-tokens-json-status-text');
        
        if (tokensJsonStatus && tokensJsonStatusText) {
          tokensJsonStatus.style.display = 'block';
          tokensJsonStatusText.textContent = `Ошибка: ${message.error}`;
          tokensJsonStatusText.style.color = '#F44336';
        }
      } else if (message.type === 'dsv-tokens-loaded-from-storage') {
        // Design System Validator - токены загружены из clientStorage при запуске
        debugLog('Design System Validator: Токены загружены из сохранённых данных', message.count);
        
        const tokensJsonStatus = document.getElementById('dsv-tokens-json-status');
        const tokensJsonStatusText = document.getElementById('dsv-tokens-json-status-text');
        const clearTokensJsonButton = document.getElementById('dsv-clear-tokens-json-button');
        
        if (tokensJsonStatus && tokensJsonStatusText) {
          tokensJsonStatus.style.display = 'block';
          
          let statusText = `Загружено токенов: ${message.count}`;
          if (message.savedAt) {
            const savedDate = new Date(message.savedAt);
            const now = new Date();
            const diffMs = now - savedDate;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            let timeAgo = '';
            if (diffMins < 1) {
              timeAgo = 'только что';
            } else if (diffMins < 60) {
              timeAgo = `${diffMins} мин. назад`;
            } else if (diffHours < 24) {
              timeAgo = `${diffHours} ч. назад`;
            } else {
              timeAgo = `${diffDays} дн. назад`;
            }
            
            statusText += ` (из памяти, ${timeAgo})`;
          } else {
            statusText += ' (из памяти)';
          }
          
          tokensJsonStatusText.textContent = statusText;
          tokensJsonStatusText.style.color = '#4CAF50';
        }
        
        if (clearTokensJsonButton) {
          clearTokensJsonButton.disabled = false;
        }
      } else if (message.type === 'dsv-tokens-imported') {
        // Design System Validator - токены импортированы
        debugLog('DSV: Токены импортированы', message.count);
        
        const tokensStatusText = document.getElementById('dsv-tokens-status-text');
        const importTokensButton = document.getElementById('dsv-import-tokens-button');
        const tokensJsonTextarea = document.getElementById('dsv-tokens-json-textarea');
        const copyJsonButton = document.getElementById('dsv-copy-json-button');
        
        if (tokensStatusText) {
          tokensStatusText.textContent = `Загружено токенов: ${message.count}`;
          tokensStatusText.style.color = '#4CAF50';
        }
        
        if (importTokensButton) {
          importTokensButton.disabled = false;
        }
        
        // Показываем JSON в textarea
        if (tokensJsonTextarea && message.json) {
          tokensJsonTextarea.value = message.json;
          if (copyJsonButton) {
            copyJsonButton.style.display = 'block';
          }
        }
      } else if (message.type === 'dsv-json-export-ready') {
        // Design System Validator - JSON готов к экспорту
        debugLog('DSV: JSON готов к экспорту');
        
        // Скачиваем файл
        const blob = new Blob([message.json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = message.filename || `figma-tokens-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        // Небольшая пауза перед alert (чтобы скачивание началось)
        setTimeout(() => {
          alert('✅ Токены экспортированы в JSON файл!');
        }, 100);
      } else if (message.type === 'dsv-json-exported') {
        // Design System Validator - JSON экспортирован
        debugLog('DSV: JSON экспортирован');
        
        // Скачиваем файл
        const jsonString = JSON.stringify(message.tokensData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `figma-tokens-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert('✅ Токены экспортированы в JSON файл!');
      } else if (message.type === 'dsv-json-loaded') {
        // Design System Validator - JSON загружен из файла
        debugLog('DSV: JSON загружен', message.count);
        
        const tokensStatusText = document.getElementById('dsv-tokens-status-text');
        const tokensJsonTextarea = document.getElementById('dsv-tokens-json-textarea');
        const copyJsonButton = document.getElementById('dsv-copy-json-button');
        
        if (tokensStatusText) {
          tokensStatusText.textContent = `Загружено токенов: ${message.count} (из JSON файла)`;
          tokensStatusText.style.color = '#4CAF50';
        }
        
        // Показываем JSON в textarea
        if (tokensJsonTextarea && message.tokensData) {
          tokensJsonTextarea.value = JSON.stringify(message.tokensData, null, 2);
          if (copyJsonButton) {
            copyJsonButton.style.display = 'block';
          }
        }
        
        alert('✅ Токены загружены из JSON файла!');
      } else if (message.type === 'dsv-tokens-not-found') {
        // Design System Validator - токены не найдены при запуске
        debugLog('DSV: Токены не найдены в памяти');
        
        const tokensStatusText = document.getElementById('dsv-tokens-status-text');
        
        if (tokensStatusText) {
          tokensStatusText.textContent = 'Токены не загружены';
          tokensStatusText.style.color = '#AAAAAA';
        }
      } else if (message.type === 'dsv-validation-complete') {
        // Design System Validator - валидация завершена (новый формат)
        debugLog('DSV: Валидация завершена', message.data);
        
        const loadingIndicator = document.getElementById('dsv-loading-indicator');
        const resultsPanel = document.getElementById('dsv-results-panel');
        const issuesSection = document.getElementById('dsv-issues-section');
        const issuesList = document.getElementById('dsv-issues-list');
        const fixAllButton = document.getElementById('dsv-fix-all-button');
        
        // Скрываем индикатор загрузки
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        
        // Разблокируем кнопку проверки
        const validateButtonMain = document.getElementById('dsv-validate-button-main');
        if (validateButtonMain) {
          validateButtonMain.disabled = false;
          validateButtonMain.textContent = 'Проверить';
        }
        
        // Показываем результаты
        if (resultsPanel) resultsPanel.style.display = 'block';
        
        // Новый формат данных
        const data = message.data;
        const report = {
          totalNodes: data.checked,
          totalIssues: data.errors.length,
          issues: data.errors
        };
        dsvCurrentReport = report;
        
        const totalNodesEl = document.getElementById('dsv-total-nodes');
        const totalIssuesEl = document.getElementById('dsv-total-issues');
        
        if (totalNodesEl) totalNodesEl.textContent = report.totalNodes;
        if (totalIssuesEl) totalIssuesEl.textContent = report.totalIssues;
        
        // Отображаем список проблем
        if (report.issues && report.issues.length > 0) {
          if (issuesSection) issuesSection.style.display = 'block';
          
          // Очищаем список
          if (issuesList) issuesList.innerHTML = '';
          
          // Группируем ошибки по нодам (как в Token Guard)
          const groupedErrors = {};
          report.issues.forEach(error => {
            const key = error.nodeId;
            if (!groupedErrors[key]) {
              groupedErrors[key] = {
                nodeName: error.nodeName,
                nodeId: error.nodeId,
                errors: []
              };
            }
            groupedErrors[key].errors.push(error);
          });
          
          // Создаём карточки для каждой ноды
          Object.values(groupedErrors).forEach(group => {
            const issueCard = document.createElement('div');
            issueCard.className = 'unified-error-card';
            issueCard.style.cursor = 'pointer';
            
            // Список ошибок для этой ноды
            const errorsList = group.errors.map(err => {
              const tokenInfo = err.suggestedToken ? 
                ` → <span style="color: #4CAF50;">${err.suggestedToken.name}</span>` : '';
              return `<div style="font-size: 10px; color: #AAAAAA; margin-top: 2px;">
                • ${err.property}: ${err.value}${tokenInfo}
              </div>`;
            }).join('');
            
            issueCard.innerHTML = `
              <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                <div style="flex: 1; min-width: 0;">
                  <div style="font-size: 12px; color: #FF9800; font-weight: 600; margin-bottom: 4px;">
                    ${group.nodeName}
                  </div>
                  <div style="font-size: 11px; color: #FFFFFF; margin-bottom: 4px;">
                    ${group.errors.length} ошибок
                  </div>
                  ${errorsList}
                </div>
                <button class="dsv-fix-node-button unified-button unified-button-primary" 
                        data-node-id="${group.nodeId}" 
                        style="font-size: 10px; padding: 6px 12px; margin-left: 8px; flex-shrink: 0; width: auto; white-space: nowrap;">
                  🔧 Исправить
                </button>
              </div>
            `;
            
            // Обработчик клика на карточку (переход к элементу)
            issueCard.addEventListener('click', (e) => {
              if (!e.target.classList.contains('dsv-fix-node-button')) {
                parent.postMessage({
                  pluginMessage: {
                    type: 'dsv-focus-node',
                    nodeId: group.nodeId
                  }
                }, '*');
              }
            });
            
            if (issuesList) issuesList.appendChild(issueCard);
          });
          
          // Добавляем обработчики на кнопки "Исправить"
          document.querySelectorAll('.dsv-fix-node-button').forEach(button => {
            button.addEventListener('click', (e) => {
              e.stopPropagation();
              const nodeId = button.getAttribute('data-node-id');
              
              // Находим все ошибки для этой ноды
              const nodeErrors = report.issues.filter(err => err.nodeId === nodeId);
              
              // Отправляем запрос на исправление всех ошибок ноды
              parent.postMessage({
                pluginMessage: {
                  type: 'dsv-fix-node-errors',
                  errors: nodeErrors
                }
              }, '*');
            });
          });
          
          // Показываем кнопку "Исправить все" если есть исправляемые проблемы
          const fixableCount = report.issues.filter(i => i.suggestedToken).length;
          if (fixAllButton && fixableCount > 0) {
            fixAllButton.style.display = 'inline-block';
            fixAllButton.textContent = `🔧 Исправить все (${fixableCount})`;
          }
        } else {
          if (issuesSection) issuesSection.style.display = 'none';
          if (fixAllButton) fixAllButton.style.display = 'none';
        }
      } else if (message.type === 'dsv-fix-success') {
        // Design System Validator - проблема исправлена
        debugLog('DSV: Проблема исправлена', message.issueId);
        
        // Перезапускаем проверку чтобы обновить результаты
        setTimeout(() => {
          runDSVValidation();
        }, 500);
      } else if (message.type === 'dsv-fix-all-complete') {
        // Design System Validator - массовое исправление завершено
        debugLog('DSV: Массовое исправление завершено', message.results);
        
        const fixAllButton = document.getElementById('dsv-fix-all-button');
        
        if (fixAllButton) {
          fixAllButton.disabled = false;
          fixAllButton.textContent = '🔧 Исправить все';
        }
        
        // Показываем результаты
        alert(`Исправлено: ${message.results.fixed}\nОшибок: ${message.results.failed}\nВсего: ${message.results.total}`);
        
        // Перезапускаем проверку
        setTimeout(() => {
          runDSVValidation();
        }, 500);
      } else if (message.type === 'dsv-tokens-status') {
        // Design System Validator - статус токенов при инициализации
        debugLog('Design System Validator: Статус токенов', message);
        
        const tokensJsonStatus = document.getElementById('dsv-tokens-json-status');
        const tokensJsonStatusText = document.getElementById('dsv-tokens-json-status-text');
        const clearTokensJsonButton = document.getElementById('dsv-clear-tokens-json-button');
        
        if (message.hasTokens && message.count > 0) {
          if (tokensJsonStatus && tokensJsonStatusText) {
            tokensJsonStatus.style.display = 'block';
            tokensJsonStatusText.textContent = `Загружено токенов: ${message.count}`;
            tokensJsonStatusText.style.color = '#4CAF50';
          }
          
          if (clearTokensJsonButton) {
            clearTokensJsonButton.disabled = false;
          }
        }
      } else {
        // Обработка неизвестных типов сообщений
        debugWarn('Получено сообщение с неизвестным типом:', message.type);
      }
    };
    
    // Функция обновления прогресса уже определена ниже с проверками параметров
    
    // Функция для debounce, чтобы ограничить частоту вызовов функции
    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }
    
    /**
     * Общая функция для отображения сообщений разных типов
     * @param {Object} options - Параметры сообщения
     * @param {string} options.type - Тип сообщения: 'error', 'success', 'progress'
     * @param {string} options.message - Текст сообщения
     * @param {number} [options.percent] - Процент прогресса (только для типа 'progress')
     */
    function displayMessage(options) {
      // Проверка обязательных параметров
      if (!options || !options.type || !options.message) {
        debugWarn('displayMessage: неверные параметры', options);
        return;
      }
      
      const { type, message, percent } = options;
      
      switch (type) {
        case 'error':
          // Отображение сообщения об ошибке
          errorContainer.style.display = 'block';
          errorContainer.innerHTML = '';
          
          const errorMessage = document.createElement('div');
          errorMessage.className = 'error-message animate-fadeIn';
          errorMessage.textContent = message;
          
          errorContainer.appendChild(errorMessage);
          break;
          
        case 'success':
          // Отображение сообщения об успехе
          errorContainer.style.display = 'block';
          errorContainer.innerHTML = '';
          
          const successMessage = document.createElement('div');
          successMessage.className = 'success-message animate-pulse';
          successMessage.textContent = message;
          
          errorContainer.appendChild(successMessage);
          break;
          
        case 'progress':
          // Обновление индикатора прогресса
          if (typeof percent !== 'number') {
            debugWarn('displayMessage: процент не является числом:', percent);
            return;
          }
          
          progressFill.style.width = `${percent}%`;
          progressText.textContent = `${message} (${percent}%)`;
          break;
          
        default:
          debugWarn('displayMessage: неизвестный тип сообщения', type);
      }
    }
    
    // Функция отображения ошибки (обертка для совместимости)
    function displayError(message) {
      if (!message) {
        debugWarn('displayError: сообщение не определено');
        message = 'Произошла неизвестная ошибка';
      }
      
      displayMessage({
        type: 'error',
        message: message
      });
    }
    
    // Функция отображения сообщения об успехе (обертка для совместимости)
    function displaySuccess(message) {
      if (!message) {
        debugWarn('displaySuccess: сообщение не определено');
        message = 'Операция выполнена успешно';
      }
      
      displayMessage({
        type: 'success',
        message: message
      });
    }
    
    // Функция обновления прогресса (обертка для совместимости)
    function updateProgress(percent, message) {
      if (typeof percent !== 'number') {
        debugWarn('updateProgress: процент не является числом:', percent);
        percent = 0;
      }
      
      if (!message) {
        debugWarn('updateProgress: сообщение не определено');
        message = 'Выполнение...';
      }
      
      displayMessage({
        type: 'progress',
        message: message,
        percent: percent
      });
    }
    
    // Запрашиваем текущие настройки при загрузке
    parent.postMessage({ pluginMessage: { type: 'get-settings' } }, '*');
    
    // Добавляем анимации для улучшения пользовательского интерфейса
    document.addEventListener('DOMContentLoaded', function() {
      // Инициализация выбора цвета по умолчанию (черный цвет)
      const blackColorButton = document.querySelector('.color-preset-btn[data-color="#000000"]');
      if (blackColorButton) {
        const defaultColor = '#000000';
        setSelectedColor(defaultColor);
        updateActiveColorButton(blackColorButton);
        customFillColor.value = defaultColor;
        customFillHex.value = defaultColor;
      }
      
      // Счетчик ошибок скрыт по умолчанию и будет показан только при наличии ошибок
      // Анимация для заголовка
      const header = document.querySelector('h1');
      if (header) {
        header.classList.add('animate-fadeIn');
        
        // Находим символ "✦" в заголовке и добавляем ему анимацию
        const headerText = header.innerHTML;
        const starSymbol = "✦";
        if (headerText.includes(starSymbol)) {
          // Заменяем символ на span с классом для анимации
          header.innerHTML = headerText.replace(
            starSymbol,
            `<span id="orbita-star" class="star-animation">${starSymbol}</span>`
          );
          
          // Функция для запуска анимации
          function animateStar() {
            const star = document.getElementById('orbita-star');
            if (star) {
              // Удаляем класс анимации, чтобы сбросить её
              star.classList.remove('star-animation');
              // Форсируем перерисовку
              void star.offsetWidth;
              // Добавляем класс анимации снова
              star.classList.add('star-animation');
            }
          }
          
          // Запускаем анимацию сразу
          animateStar();
          
          // Запускаем анимацию каждые 15 секунд
          setInterval(animateStar, 15000);
        }
      }
      
      // Анимация для кнопок
      const buttons = document.querySelectorAll('button');
      buttons.forEach((button, index) => {
        button.classList.add('animate-slideIn');
        button.style.animationDelay = `${index * 0.1}s`;
      });
      
      // Добавляем классы анимации для выпадающего меню настроек
      if (settingsDropdown) {
        settingsDropdown.classList.add('animate-fadeIn');
      }
    });
    
    // Функция для корректировки положения tooltip
    function adjustTooltipPosition() {
      // Получаем все tooltip элементы
      const tooltips = document.querySelectorAll('.tooltip');
      
      tooltips.forEach(tooltip => {
        // Сбрасываем предыдущие стили
        tooltip.style.left = '';
        tooltip.style.right = '';
        tooltip.style.bottom = '';
        tooltip.style.top = '';
        tooltip.style.marginLeft = '';
        tooltip.style.marginTop = '';
        
        // Получаем родительский элемент (иконка вопроса или кнопка фикс)
        const parent = tooltip.parentElement;
        
        // Проверяем видимость tooltip или если родитель в состоянии hover
        if (getComputedStyle(tooltip).visibility === 'visible' || parent.matches(':hover')) {
          // Получаем размеры и позицию tooltip и окна
          const tooltipRect = tooltip.getBoundingClientRect();
          const parentRect = parent.getBoundingClientRect();
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;
          const headerHeight = document.querySelector('.header-container').getBoundingClientRect().height;
          
          // Проверяем, выходит ли tooltip за левый край окна
          if (tooltipRect.left < 0) {
            tooltip.style.left = '0';
            tooltip.style.right = 'auto';
            tooltip.style.marginLeft = '0';
          }
          
          // Проверяем, выходит ли tooltip за правый край окна
          if (tooltipRect.right > windowWidth) {
            tooltip.style.left = 'auto';
            tooltip.style.right = '0';
            tooltip.style.marginLeft = '0';
          }
          
          // Всегда показываем тултип над элементом, даже если он выходит за верхний край окна
          // Это важнее, чем перекрытие шапкой
          // Комментируем эту проверку, чтобы тултип всегда был сверху
          /*
          if (tooltipRect.top < headerHeight || tooltipRect.top < 0) {
            tooltip.style.bottom = 'auto';
            tooltip.style.top = '100%';
            tooltip.style.marginTop = '5px';
          }
          */
          
          // Проверяем, выходит ли tooltip за нижний край окна
          if (tooltipRect.bottom > windowHeight) {
            tooltip.style.top = 'auto';
            tooltip.style.bottom = '100%';
            tooltip.style.marginBottom = '5px';
          }
        }
      });
    }
    
    // Создаем дебаунсированную версию функции adjustTooltipPosition
    const debouncedAdjustTooltipPosition = debounce(adjustTooltipPosition, 100);
    
    // Добавляем обработчики событий для корректировки положения tooltip
    // Используем делегирование событий для лучшей производительности
    document.addEventListener('mouseover', function(e) {
      if (e.target.closest('.tooltip-icon') || e.target.closest('.fix-button')) {
        debouncedAdjustTooltipPosition();
      }
    });
    
    // Добавляем обработчик для предотвращения частых вызовов при движении мыши
    document.addEventListener('mousemove', debounce(function(e) {
      if (document.querySelector('.tooltip[style*="visibility: visible"]')) {
        debouncedAdjustTooltipPosition();
      }
    }, 100));
    
    // Добавляем обработчик события изменения размера окна
    window.addEventListener('resize', debouncedAdjustTooltipPosition);
    
    // Вызываем функцию adjustTooltipPosition при загрузке страницы
    document.addEventListener('DOMContentLoaded', debouncedAdjustTooltipPosition);
    
    // Переопределяем функцию отображения результатов для добавления анимаций
    // Сохраняем оригинальную функцию, но не используем ее, так как полностью переопределяем
    /**
     * Отображает результаты проверки иконок с оптимизацией производительности
     * @param {Array} results - Массив результатов проверки
     */
    window.displayResults = function(results) {
      // Проверяем, что results является массивом
      if (!Array.isArray(results)) {
        debugWarn('displayResults: results не является массивом', results);
        results = [];
      }
      
      // Проверяем, что resultsContainer существует
      if (!resultsContainer) {
        console.error('displayResults: resultsContainer не найден');
        return;
      }
      
      // Очищаем контейнер результатов
      resultsContainer.innerHTML = '';
      resultsContainer.classList.add('animate-fadeIn');
      
      // Обновляем badge с количеством ошибок
      updateErrorBadge(results);
      
      // Если нет ошибок, показываем сообщение об успехе
      if (results.length === 0) {
        const successMessage = document.createElement('div');
        successMessage.className = 'success-message animate-pulse';
        successMessage.textContent = 'Все иконки соответствуют требованиям! 🎉';
        resultsContainer.appendChild(successMessage);
        return;
      }
      
      // Определяем, нужна ли ленивая загрузка (если результатов больше 20)
      const needsLazyLoading = results.length > 20;
      const initialBatchSize = 10;
      
      // Создаем DocumentFragment для более эффективного добавления элементов
      const fragment = document.createDocumentFragment();
      
      // Функция для создания элементов результатов
      const createResultElements = (startIndex, endIndex) => {
        // Создаем элементы для каждой ошибки в указанном диапазоне
        for (let i = startIndex; i < endIndex && i < results.length; i++) {
          const result = results[i];
          
          // Проверяем, что result содержит необходимые поля
          if (!result || typeof result !== 'object') {
            debugWarn('displayResults: некорректный элемент результата', result);
            continue;
          }
          
          // Создаем элемент для ошибки
          const errorItem = createErrorItem(result, i);
          
          // Добавляем элемент в фрагмент
          fragment.appendChild(errorItem);
        }
        
        // Добавляем фрагмент в контейнер результатов
        resultsContainer.appendChild(fragment);
        
        // Добавляем обработчик для корректировки положения tooltip после создания элементов
        requestAnimationFrame(adjustTooltipPosition);
      };
      
      // Если нужна ленивая загрузка, добавляем первую партию элементов и настраиваем IntersectionObserver
      if (needsLazyLoading) {
        // Создаем первую партию элементов
        createResultElements(0, initialBatchSize);
        
        // Добавляем индикатор загрузки
        const loadingIndicator = document.createElement('div');
        loadingIndicator.id = 'loading-more-indicator';
        loadingIndicator.className = 'loading';
        loadingIndicator.textContent = 'Загрузка дополнительных результатов...';
        resultsContainer.appendChild(loadingIndicator);
        
        // Настраиваем IntersectionObserver для загрузки дополнительных элементов при прокрутке
        let currentIndex = initialBatchSize;
        const batchSize = 5; // Количество элементов, загружаемых за раз
        
        const observer = new IntersectionObserver((entries) => {
          if (entries[0].isIntersecting && currentIndex < results.length) {
            // Загружаем следующую партию элементов
            const nextBatchEnd = Math.min(currentIndex + batchSize, results.length);
            createResultElements(currentIndex, nextBatchEnd);
            currentIndex = nextBatchEnd;
            
            // Если все элементы загружены, удаляем индикатор загрузки и отключаем observer
            if (currentIndex >= results.length) {
              loadingIndicator.remove();
              observer.disconnect();
            }
          }
        }, { threshold: 0.1 });
        
        // Начинаем наблюдение за индикатором загрузки
        observer.observe(loadingIndicator);
      } else {
        // Если ленивая загрузка не нужна, создаем все элементы сразу
        createResultElements(0, results.length);
      }
    };
    
    /**
     * Обновляет счетчик ошибок на основе результатов проверки
     * @param {Array} results - Массив результатов проверки
     */
    function updateErrorBadge(results) {
      if (!results || !Array.isArray(results) || !errorBadge) {
        return;
      }
      
      if (results.length === 0) {
        // Скрываем счетчик ошибок, если ошибок нет
        errorBadge.style.display = 'none';
        return;
      }
      
      // Подсчитываем общее количество ошибок
      let totalErrors = 0;
      results.forEach(result => {
        if (result && Array.isArray(result.errors)) {
          totalErrors += result.errors.length;
        }
      });
      
      // Показываем счетчик ошибок только если есть ошибки
      if (totalErrors > 0) {
        errorBadge.textContent = totalErrors;
        errorBadge.style.display = 'inline-flex';
        errorBadge.classList.add('animate-pulse');
      } else {
        errorBadge.style.display = 'none';
      }
    }
    
    /**
     * Создает элемент для отображения ошибки компонента
     * @param {Object} result - Результат проверки компонента
     * @param {number} index - Индекс результата в массиве
     * @returns {HTMLElement} - Созданный элемент
     */
    function createErrorItem(result, index) {
      const errorItem = document.createElement('div');
      errorItem.className = 'error-item';
      
      // Добавляем анимацию с задержкой (ограничиваем максимальную задержку)
      errorItem.classList.add('animate-slideIn');
      errorItem.style.animationDelay = `${Math.min(index * 0.05, 0.5)}s`;
      
      // Создаем элемент для названия компонента
      const componentName = document.createElement('div');
      componentName.className = 'component-name';
      componentName.textContent = result.nodeName || 'Неизвестный компонент';
      
      // Добавляем обработчик клика для перехода к компоненту
      if (result.nodeId) {
        componentName.addEventListener('click', debounce(() => {
          parent.postMessage({
            pluginMessage: {
              type: 'focus-node',
              nodeId: result.nodeId
            }
          }, '*');
        }, 300));
      }
      
      errorItem.appendChild(componentName);
      
      // Добавляем название родительского компонента, если есть
      if (result.parentName) {
        const parentName = document.createElement('div');
        parentName.className = 'parent-name';
        parentName.textContent = `◇ ${result.parentName}`;
        errorItem.appendChild(parentName);
      }
      
      // Создаем список ошибок
      const errorList = document.createElement('ul');
      errorList.className = 'error-list';
      
      // Проверяем, что у результата есть массив ошибок
      if (!Array.isArray(result.errors)) {
        debugWarn('createErrorItem: отсутствует массив ошибок в результате', result);
        return errorItem;
      }
      
      // Создаем элементы для каждой ошибки
      result.errors.forEach((error, errorIndex) => {
        // Проверяем тип ошибки - это может быть строка или объект
        let errorObj;
        if (typeof error === 'string') {
          // Если это строка (случай, когда ничего не выбрано или нет компонентов),
          // преобразуем её в объект с полем message
          errorObj = {
            message: error,
            type: 'general'
          };
        } else if (error && typeof error === 'object' && error.message) {
          errorObj = error;
        } else {
          debugWarn('createErrorItem: некорректная ошибка', error);
          return;
        }
        
        const errorListItem = document.createElement('li');
        
        // Добавляем анимацию с задержкой (ограничиваем максимальную задержку)
        errorListItem.classList.add('animate-fadeIn');
        errorListItem.style.animationDelay = `${Math.min((index * 0.05) + (errorIndex * 0.02), 0.7)}s`;
        
        // Создаем контейнер для сообщения об ошибке
        const errorMessage = document.createElement('div');
        errorMessage.className = 'error-message';
        
        // Добавляем текст ошибки
        const errorText = document.createElement('span');
        errorText.textContent = errorObj.message;
        errorMessage.appendChild(errorText);
        
        // Добавляем иконку с подсказкой, если есть tooltip
        if (errorObj.tooltip) {
          const tooltipIcon = document.createElement('div');
          tooltipIcon.className = 'tooltip-icon';
          tooltipIcon.textContent = '?';
          
          const tooltip = document.createElement('div');
          tooltip.className = 'tooltip';
          tooltip.textContent = errorObj.tooltip;
          
          tooltipIcon.appendChild(tooltip);
          errorMessage.appendChild(tooltipIcon);
        }
        
        errorListItem.appendChild(errorMessage);
        
        // Создаем кнопку "фикс" для ошибки
        const fixButton = document.createElement('button');
        fixButton.className = 'fix-button';
        
        // Добавляем SVG-иконку и тултип
        fixButton.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M7.99899 20L14.999 12.997C15.5285 12.4679 15.8261 11.7501 15.8264 11.0016C15.8267 10.253 15.5296 9.53501 15.0005 9.0055C14.4714 8.476 13.7536 8.17837 13.0051 8.17809C12.2565 8.1778 11.5385 8.47489 11.009 9.004L4.00199 16.001C3.73935 16.2634 3.53097 16.5751 3.38875 16.918C3.24654 17.261 3.17327 17.6286 3.17313 17.9999C3.17299 18.3712 3.24598 18.7389 3.38794 19.082C3.5299 19.4251 3.73805 19.7369 4.00049 19.9995C4.26294 20.2621 4.57455 20.4705 4.91753 20.6127C5.26051 20.755 5.62814 20.8282 5.99943 20.8284C6.37073 20.8285 6.73841 20.7555 7.0815 20.6136C7.42458 20.4716 7.73635 20.2624 7.99899 20ZM11 11L13 13L14 12C14.1313 11.8687 14.2355 11.7128 14.3066 11.5412C14.3776 11.3696 14.4142 11.1857 14.4142 11C14.4142 10.8143 14.3776 10.6304 14.3066 10.4588C14.2355 10.2872 14.1313 10.1313 14 10C13.8687 9.86868 13.7128 9.76451 13.5412 9.69344C13.3696 9.62237 13.1857 9.58579 13 9.58579C12.8143 9.58579 12.6304 9.62237 12.4588 9.69344C12.2872 9.76451 12.1313 9.86868 12 10L11 11Z" fill="white"/>
            <path d="M6.75901 4.897C6.82501 4.65 7.17501 4.65 7.24101 4.897L7.60001 6.225C7.61142 6.26715 7.63367 6.30558 7.66455 6.33646C7.69543 6.36734 7.73386 6.38959 7.77601 6.401L9.10401 6.759C9.35101 6.825 9.35101 7.175 9.10401 7.241L7.77501 7.6C7.73286 7.61141 7.69443 7.63366 7.66355 7.66454C7.63267 7.69542 7.61042 7.73385 7.59901 7.776L7.24001 9.103C7.17401 9.35 6.82401 9.35 6.75801 9.103L6.40001 7.775C6.3886 7.73285 6.36635 7.69442 6.33547 7.66354C6.30459 7.63266 6.26616 7.61041 6.22401 7.599L4.89501 7.241C4.64901 7.175 4.64901 6.825 4.89501 6.759L6.22501 6.4C6.26716 6.38859 6.30559 6.36634 6.33647 6.33546C6.36735 6.30458 6.3896 6.26615 6.40101 6.224L6.75901 4.897ZM16.759 3.897C16.825 3.65 17.175 3.65 17.241 3.897L17.599 5.225C17.6104 5.26715 17.6327 5.30558 17.6636 5.33646C17.6944 5.36734 17.7329 5.38959 17.775 5.401L19.103 5.759C19.35 5.825 19.35 6.175 19.103 6.241L17.775 6.599C17.7329 6.61041 17.6944 6.63266 17.6636 6.66354C17.6327 6.69442 17.6104 6.73285 17.599 6.775L17.241 8.103C17.175 8.35 16.825 8.35 16.759 8.103L16.4 6.775C16.3885 6.73273 16.3661 6.69422 16.335 6.66333C16.304 6.63244 16.2653 6.61026 16.223 6.599L14.895 6.241C14.649 6.175 14.649 5.825 14.895 5.759L16.223 5.401C16.2653 5.38974 16.304 5.36756 16.335 5.33667C16.3661 5.30578 16.3885 5.26727 16.4 5.225L16.759 3.897ZM17.759 12.897C17.825 12.65 18.175 12.65 18.241 12.897L18.599 14.225C18.6104 14.2672 18.6327 14.3056 18.6636 14.3365C18.6944 14.3673 18.7329 14.3896 18.775 14.401L20.103 14.759C20.35 14.825 20.35 15.175 20.103 15.241L18.775 15.599C18.7329 15.6104 18.6944 15.6327 18.6636 15.6635C18.6327 15.6944 18.6104 15.7328 18.599 15.775L18.241 17.103C18.175 17.35 17.825 17.35 17.759 17.103L17.401 15.775C17.3895 15.7327 17.3671 15.6942 17.336 15.6633C17.305 15.6324 17.2663 15.6103 17.224 15.599L15.896 15.241C15.65 15.175 15.65 14.825 15.896 14.759L17.224 14.401C17.2663 14.3897 17.305 14.3676 17.336 14.3367C17.3671 14.3058 17.3895 14.2673 17.401 14.225L17.759 12.897Z" fill="white"/>
          </svg>
          <div class="tooltip">Попробовать исправить</div>
        `;
        
        // Добавляем обработчик клика с защитой от двойного клика
        // Если nodeId отсутствует (общая ошибка) или тип ошибки general, делаем кнопку неактивной
        if (!result.nodeId || errorObj.type === 'general' || errorObj.type === 'empty-color-layer') {
          fixButton.style.opacity = '0.5';
          fixButton.style.cursor = 'not-allowed';
          fixButton.disabled = true;
          
          // Меняем текст тултипа
          const tooltip = fixButton.querySelector('.tooltip');
          if (tooltip) {
            if (errorObj.type === 'empty-color-layer') {
              tooltip.textContent = 'Временно не работает';
            } else {
              tooltip.textContent = 'Требуется действие пользователя';
            }
          }
        } else {
          fixButton.addEventListener('click', debounce(() => {
            // Отправляем сообщение в плагин для исправления ошибки
            parent.postMessage({
              pluginMessage: {
                type: 'fix-error',
                nodeId: result.nodeId,
                errorType: errorObj.type
              }
            }, '*');
            
            // Визуальная обратная связь для пользователя
            fixButton.classList.add('animate-pulse');
            setTimeout(() => fixButton.classList.remove('animate-pulse'), 500);
          }, 300));
        }
        
        errorListItem.appendChild(fixButton);
        errorList.appendChild(errorListItem);
      });
      
      errorItem.appendChild(errorList);
      return errorItem;
    }
    
    // Функция создания и загрузки ZIP архива
    async function createAndDownloadZip() {
      try {
        debugLog('SVG Export: Создаем ZIP архив с', svgFiles.length, 'файлами');
        
        // Проверяем наличие JSZip
        if (typeof JSZip === 'undefined') {
          debugLog('SVG Export: JSZip не загружена, используем альтернативный метод');
          downloadFilesSequentially();
          return;
        }
        
        debugLog('SVG Export: JSZip доступна, создаем ZIP архив');
        
        // Создаем новый ZIP архив
        const zip = new JSZip();
        
        // Добавляем все SVG файлы в архив
        svgFiles.forEach(file => {
          debugLog('SVG Export: Добавляем в ZIP:', file.name);
          zip.file(file.name, file.data);
        });
        
        // Генерируем ZIP файл
        const zipBlob = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: {
            level: 6
          }
        });
        
        // Создаем имя архива на основе текущей даты
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
        const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '-'); // HH-MM-SS
        const zipFileName = `orbita-icons-${dateStr}-${timeStr}.zip`;
        
        // Создаем ссылку для скачивания
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = zipFileName;
        
        // Автоматически скачиваем файл
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Освобождаем память
        URL.revokeObjectURL(url);
        
        debugLog('SVG Export: ZIP архив успешно создан и загружен:', zipFileName);
        
        // Показываем сообщение об успехе
        displayMessage({
          type: 'success',
          message: `ZIP архив с ${svgFiles.length} иконками успешно загружен!`
        });
        
        // Очищаем массив файлов
        svgFiles = [];
        expectedFilesCount = 0;
        
      } catch (error) {
        console.error('SVG Export: Ошибка при создании ZIP архива:', error);
        displayMessage({
          type: 'error',
          message: `Ошибка при создании архива: ${error.message}`
        });
      }
    }
    
    // Альтернативная функция для скачивания файлов по одному (когда JSZip недоступна)
    function downloadFilesSequentially() {
      debugLog('SVG Export: Начинаем последовательное скачивание', svgFiles.length, 'файлов');
      
      let downloadIndex = 0;
      
      function downloadNextFile() {
        if (downloadIndex >= svgFiles.length) {
          debugLog('SVG Export: Все файлы успешно скачаны');
          displayMessage({
            type: 'success',
            message: `Все ${svgFiles.length} иконок скачаны по отдельности!`
          });
          
          // Очищаем массив файлов
          svgFiles = [];
          expectedFilesCount = 0;
          return;
        }
        
        const file = svgFiles[downloadIndex];
        debugLog(`SVG Export: Скачиваем файл ${downloadIndex + 1}/${svgFiles.length}:`, file.name);
        
        try {
          // Создаем Blob из SVG данных
          const blob = new Blob([file.data], { type: 'image/svg+xml' });
          
          // Создаем ссылку для скачивания
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = file.name;
          
          // Автоматически скачиваем файл
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          // Освобождаем память
          URL.revokeObjectURL(url);
          
          downloadIndex++;
          
          // Переходим к следующему файлу с небольшой задержкой
          setTimeout(downloadNextFile, 300); // 300ms задержка между скачиваниями
          
        } catch (error) {
          console.error('SVG Export: Ошибка при скачивании файла:', file.name, error);
          downloadIndex++;
          setTimeout(downloadNextFile, 300);
        }
      }
      
      // Показываем сообщение пользователю
      displayMessage({
        type: 'success',
        message: `Начинаем скачивание ${svgFiles.length} файлов. Ваш браузер может запросить разрешение на множественные загрузки.`
      });
      
      // Начинаем скачивание
      downloadNextFile();
    }
    
    // Функции displayError и displaySuccess уже определены выше с проверками параметров
    
    // ============================================
    // AI Design Lint функции
    // ============================================
    
    const analyzeDesignButton = document.getElementById('analyze-design-button');
    const yandexTokenInput = document.getElementById('yandex-token');
    const aiPromptInput = document.getElementById('ai-prompt');
    const aiAnalysisResult = document.getElementById('ai-analysis-result');
    const aiMainScreen = document.getElementById('ai-main-screen');
    const aiSettingsScreen = document.getElementById('ai-settings-screen');
    const aiSettingsButton = document.getElementById('ai-settings-button');
    const aiSettingsBackButton = document.getElementById('ai-settings-back-button');
    const aiSaveSettingsButton = document.getElementById('ai-save-settings-button');
    const aiLoadJsonButton = document.getElementById('ai-load-json-button');
    const aiClearJsonButton = document.getElementById('ai-clear-json-button');
    const aiJsonFileInput = document.getElementById('ai-json-file-input');
    const aiJsonStatus = document.getElementById('ai-json-status');
    const aiJsonStatusText = document.getElementById('ai-json-status-text');
    const aiViewJsonButton = document.getElementById('ai-view-json-button');
    const aiJsonModal = document.getElementById('ai-json-modal');
    const aiCloseJsonModal = document.getElementById('ai-close-json-modal');
    const aiJsonPreview = document.getElementById('ai-json-preview');
    const aiChatSection = document.getElementById('ai-chat-section');
    const aiFollowUpInput = document.getElementById('ai-follow-up-input');
    const aiAskQuestionButton = document.getElementById('ai-ask-question-button');
    const aiClearHistoryButton = document.getElementById('ai-clear-history-button');
    const aiTokensCount = document.getElementById('ai-tokens-count');
    const aiChatTokensInfo = document.getElementById('ai-chat-tokens-info');
    
    // Хранилище для загруженного JSON
    let customDesignSystemJson = null;
    
    // История чата с AI
    let aiChatHistory = [];
    let lastDesignInfo = null;
    let lastSystemPrompt = null;
    
    // Переключение на экран настроек
    if (aiSettingsButton) {
      aiSettingsButton.addEventListener('click', () => {
        aiMainScreen.style.display = 'none';
        aiSettingsScreen.style.display = 'block';
      });
    }
    
    // Возврат на основной экран
    if (aiSettingsBackButton) {
      aiSettingsBackButton.addEventListener('click', () => {
        aiSettingsScreen.style.display = 'none';
        aiMainScreen.style.display = 'block';
      });
    }
    
    // Загрузка JSON файла
    if (aiLoadJsonButton && aiJsonFileInput) {
      aiLoadJsonButton.addEventListener('click', () => {
        aiJsonFileInput.click();
      });
      
      aiJsonFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const jsonData = JSON.parse(event.target.result);
              customDesignSystemJson = jsonData;
              
              // Сохраняем в clientStorage
              saveCustomDesignSystem(jsonData);
              
              // Обновляем UI
              updateJsonStatus(file.name, true);
              
              debugLog('AI Design Lint: JSON дизайн-системы загружен:', jsonData);
            } catch (error) {
              console.error('Ошибка парсинга JSON:', error);
              displayMessage({
                type: 'error',
                message: 'Ошибка чтения JSON файла. Проверьте формат.'
              });
            }
          };
          reader.readAsText(file);
        }
      });
    }
    
    // Очистка JSON
    if (aiClearJsonButton) {
      aiClearJsonButton.addEventListener('click', () => {
        customDesignSystemJson = null;
        clearCustomDesignSystem();
        updateJsonStatus('', false);
        aiJsonFileInput.value = '';
      });
    }
    
    // Просмотр JSON
    if (aiViewJsonButton && aiJsonModal && aiJsonPreview) {
      aiViewJsonButton.addEventListener('click', () => {
        if (customDesignSystemJson) {
          aiJsonPreview.textContent = JSON.stringify(customDesignSystemJson, null, 2);
          aiJsonModal.style.display = 'block';
        }
      });
    }
    
    // Закрытие модального окна
    if (aiCloseJsonModal && aiJsonModal) {
      aiCloseJsonModal.addEventListener('click', () => {
        aiJsonModal.style.display = 'none';
      });
      
      // Закрытие по клику на фон
      aiJsonModal.addEventListener('click', (e) => {
        if (e.target === aiJsonModal) {
          aiJsonModal.style.display = 'none';
        }
      });
    }
    
    // Обновление статуса JSON
    function updateJsonStatus(fileName, hasJson) {
      if (aiJsonStatus && aiJsonStatusText && aiClearJsonButton) {
        if (hasJson) {
          aiJsonStatus.style.display = 'block';
          aiJsonStatusText.textContent = `Загружен: ${fileName}`;
          aiJsonStatusText.style.color = '#4CAF50';
          aiClearJsonButton.disabled = false;
        } else {
          aiJsonStatus.style.display = 'none';
          aiJsonStatusText.textContent = 'Файл не загружен';
          aiJsonStatusText.style.color = '#AAAAAA';
          aiClearJsonButton.disabled = true;
        }
      }
    }
    
    // Сохранение кастомной дизайн-системы
    function saveCustomDesignSystem(jsonData) {
      parent.postMessage({
        pluginMessage: {
          type: 'save-custom-design-system',
          data: jsonData
        }
      }, '*');
    }
    
    // Очистка кастомной дизайн-системы
    function clearCustomDesignSystem() {
      parent.postMessage({
        pluginMessage: {
          type: 'clear-custom-design-system'
        }
      }, '*');
    }
    
    // Загрузка сохраненной кастомной дизайн-системы
    function loadCustomDesignSystem() {
      parent.postMessage({
        pluginMessage: {
          type: 'get-custom-design-system'
        }
      }, '*');
    }
    
    // Сохранение настроек
    if (aiSaveSettingsButton) {
      aiSaveSettingsButton.addEventListener('click', () => {
        const token = yandexTokenInput ? yandexTokenInput.value.trim() : '';
        
        if (token) {
          saveToken(token);
        }
        
        // Показываем уведомление
        aiSaveSettingsButton.textContent = 'Сохранено!';
        setTimeout(() => {
          aiSaveSettingsButton.textContent = 'Сохранить настройки';
          // Возвращаемся на основной экран
          aiSettingsScreen.style.display = 'none';
          aiMainScreen.style.display = 'block';
        }, 1500);
      });
    }
    
    // Загрузка сохраненного токена через Figma API
    function loadSavedToken() {
      // Запрашиваем токен из плагина
      parent.postMessage({
        pluginMessage: {
          type: 'get-saved-token'
        }
      }, '*');
    }
    
    // Сохранение токена через Figma API
    function saveToken(token) {
      if (token) {
        parent.postMessage({
          pluginMessage: {
            type: 'save-token',
            token: token
          }
        }, '*');
      }
    }
    
    // Обработчик клика на кнопку "Анализировать дизайн"
    if (analyzeDesignButton) {
      analyzeDesignButton.addEventListener('click', async () => {
        console.log('AI Design Lint: Кнопка нажата');
        
        // Показываем индикатор загрузки
        analyzeDesignButton.textContent = 'Анализируем...';
        analyzeDesignButton.disabled = true;
        
        // Скрываем старые результаты
        if (aiAnalysisResult) {
          aiAnalysisResult.style.display = 'none';
        }
        
        // Показываем панель локального анализа
        const componentAnalysisPanel = document.getElementById('component-analysis-panel');
        if (componentAnalysisPanel) {
          componentAnalysisPanel.style.display = 'block';
          // НЕ удаляем содержимое! Просто добавляем индикатор загрузки в начало
          const loadingIndicator = document.createElement('div');
          loadingIndicator.id = 'analysis-loading-indicator';
          loadingIndicator.style.cssText = 'color: #AAAAAA; text-align: center; padding: 32px; background: #2A2A32; border-radius: 8px; margin-bottom: 16px;';
          loadingIndicator.textContent = 'Анализируем компонент...';
          componentAnalysisPanel.insertBefore(loadingIndicator, componentAnalysisPanel.firstChild);
          console.log('AI Design Lint: Панель анализа показана');
        } else {
          console.error('AI Design Lint: Панель component-analysis-panel не найдена');
        }
        
        // Отправляем запрос на локальный анализ компонента
        console.log('AI Design Lint: Отправляем сообщение analyze-component');
        parent.postMessage({
          pluginMessage: {
            type: 'analyze-component'
          }
        }, '*');
      });
    } else {
      console.error('AI Design Lint: Кнопка analyze-design-button не найдена');
    }

    // ============================================
    // Функции для локального анализа компонентов
    // ============================================
    
    // Функция переключения секций
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      const toggle = event.target;
      
      if (section.style.display === 'none') {
        section.style.display = 'block';
        toggle.textContent = '▼';
      } else {
        section.style.display = 'none';
        toggle.textContent = '▶';
      }
    }
    
    // Функция отображения результатов анализа
    function displayAnalysisResults(analysis) {
      console.log('AI Design Lint: displayAnalysisResults вызвана с данными:', analysis);
      
      // Сохраняем анализ для AI чата
      currentAnalysis = analysis;
      
      // Проверяем, что панель существует
      const componentAnalysisPanel = document.getElementById('component-analysis-panel');
      if (!componentAnalysisPanel) {
        console.error('AI Design Lint: Панель component-analysis-panel не найдена при отображении результатов');
        return;
      }
      
      // Удаляем индикатор загрузки, если он есть
      const loadingIndicator = document.getElementById('analysis-loading-indicator');
      if (loadingIndicator) {
        loadingIndicator.remove();
      }
      
      // Показываем панель
      componentAnalysisPanel.style.display = 'block';
      
      // Обновляем оценку
      const scoreNumber = document.getElementById('score-number');
      const layersCount = document.getElementById('layers-count');
      const tokensCount = document.getElementById('tokens-count');
      const hardcodedCount = document.getElementById('hardcoded-count');
      const issuesCount = document.getElementById('issues-count');
      
      console.log('AI Design Lint: Обновляем счетчики:', {
        score: analysis.score,
        layers: analysis.totalLayers,
        tokens: analysis.tokensUsed?.length,
        hardcoded: analysis.hardcodedValues?.length,
        issues: analysis.recommendations?.length
      });
      
      if (scoreNumber) scoreNumber.textContent = analysis.score || 0;
      if (layersCount) layersCount.textContent = analysis.totalLayers || 0;
      if (tokensCount) tokensCount.textContent = analysis.tokensUsed ? analysis.tokensUsed.length : 0;
      if (hardcodedCount) hardcodedCount.textContent = analysis.hardcodedValues ? analysis.hardcodedValues.length : 0;
      if (issuesCount) issuesCount.textContent = analysis.recommendations ? analysis.recommendations.length : 0;
      
      // Отображаем токены
      displayTokens(analysis.tokensUsed || []);
      
      // Отображаем hardcoded значения
      displayHardcodedValues(analysis.hardcodedValues || []);
      
      // Отображаем рекомендации
      displayRecommendations(analysis.recommendations || []);
      
      // Отображаем предложения токенов
      displayTokenSuggestions(analysis.tokenSuggestions || []);
      
      // Восстанавливаем кнопку
      const analyzeDesignButton = document.getElementById('analyze-design-button');
      if (analyzeDesignButton) {
        analyzeDesignButton.textContent = 'Анализировать дизайн';
        analyzeDesignButton.disabled = false;
      }
      
      console.log('AI Design Lint: Результаты отображены успешно');
    }
    
    // Отображение токенов
    function displayTokens(tokens) {
      const tokensList = document.getElementById('tokens-list');
      if (!tokensList) return;
      
      if (tokens.length === 0) {
        tokensList.innerHTML = '<div style="color: #AAAAAA; font-size: 12px; text-align: center; padding: 16px;">Токены не найдены</div>';
          return;
        }
        
      tokensList.innerHTML = tokens.map(token => `
        <div class="token-item" onclick="highlightLayer('${token.nodeId}', event)" style="cursor: pointer;" title="Кликните для перехода к слою в Figma">
          <div class="token-info">
            <div class="token-name">${token.name}</div>
            <div class="token-type">${token.type}</div>
          </div>
          <div style="font-size: 11px; color: #AAAAAA;">${token.path}</div>
        </div>
      `).join('');
    }
    
    // Отображение hardcoded значений
    function displayHardcodedValues(hardcodedValues) {
      const hardcodedList = document.getElementById('hardcoded-list');
      if (!hardcodedList) return;
      
      if (hardcodedValues.length === 0) {
        hardcodedList.innerHTML = '<div style="color: #4CAF50; font-size: 12px; text-align: center; padding: 16px;">Все значения используют токены</div>';
        return;
      }
      
      hardcodedList.innerHTML = hardcodedValues.map(item => `
        <div class="hardcoded-item" onclick="highlightLayer('${item.nodeId}', event)" style="cursor: pointer;" title="Кликните для перехода к слою в Figma">
          <div class="hardcoded-info">
            <div class="hardcoded-type">${item.type}</div>
            <div class="hardcoded-description">${item.description}</div>
          </div>
          <div class="hardcoded-value">${item.value}</div>
        </div>
      `).join('');
    }
    
    // Отображение рекомендаций
    function displayRecommendations(recommendations) {
      const recommendationsList = document.getElementById('recommendations-list');
      if (!recommendationsList) return;
      
      if (recommendations.length === 0) {
        recommendationsList.innerHTML = '<div style="color: #4CAF50; font-size: 12px; text-align: center; padding: 16px;">Компонент соответствует стандартам</div>';
        return;
      }
      
      recommendationsList.innerHTML = recommendations.map(rec => `
        <div class="recommendation-item">
          <span class="recommendation-priority ${rec.priority}">${rec.priority.toUpperCase()}</span>
          <div class="recommendation-message">${rec.message}</div>
        </div>
      `).join('');
    }
    
    // Отображение предложений токенов
    function displayTokenSuggestions(suggestions) {
      const suggestionsList = document.getElementById('token-suggestions-list');
      if (!suggestionsList) return;
      
      if (suggestions.length === 0) {
        suggestionsList.innerHTML = '<div style="color: #4CAF50; font-size: 12px; text-align: center; padding: 16px;">Все значения уже используют токены</div>';
        return;
      }
      
      suggestionsList.innerHTML = suggestions.map(suggestion => `
        <div class="token-suggestion-item" onclick="highlightLayer('${suggestion.hardcodedValue.nodeId}', event)" style="cursor: pointer;" title="Кликните для перехода к слою в Figma">
          <div class="suggestion-header">
            <div class="suggestion-hardcoded">${suggestion.hardcodedValue.type}: ${suggestion.hardcodedValue.value}</div>
            <div class="suggestion-confidence">${Math.round(suggestion.confidence * 100)}%</div>
          </div>
          <div class="suggestion-token">→ ${suggestion.suggestedToken.name}</div>
          <div class="suggestion-reason">${suggestion.reason}</div>
        </div>
      `).join('');
    }
    
    // Функция подсветки слоя
    function highlightLayer(nodeId, event) {
      console.log('AI Design Lint: Переход к слою:', nodeId);
      
      // Добавляем визуальную обратную связь для всех кликабельных элементов
      if (event) {
        const clickedElement = event.target.closest('.hardcoded-item, .token-item, .token-suggestion-item');
        if (clickedElement) {
          const originalBg = clickedElement.style.backgroundColor;
          const originalColor = clickedElement.style.color;
          
          clickedElement.style.backgroundColor = '#F86025';
          clickedElement.style.color = 'white';
          clickedElement.style.transition = 'all 0.15s ease';
          
          setTimeout(() => {
            clickedElement.style.backgroundColor = originalBg;
            clickedElement.style.color = originalColor;
          }, 200);
        }
      }
      
      debugLog('Highlighting layer:', nodeId);
      
      // Отправляем команду в плагин для подсветки слоя
      parent.postMessage({
        pluginMessage: {
          type: 'highlight-layer',
          nodeId: nodeId
        }
      }, '*');
    }
    
    // Обработка сообщений от плагина
    window.addEventListener('message', (event) => {
      const message = event.data.pluginMessage;
      
      if (message.type === 'analysis-result') {
        console.log('AI Design Lint: Получен analysis-result:', message);
        
        // Удаляем индикатор загрузки
        const loadingIndicator = document.getElementById('analysis-loading-indicator');
        if (loadingIndicator) {
          loadingIndicator.remove();
        }
        
        if (message.success) {
          console.log('AI Design Lint: Анализ успешен, вызываем displayAnalysisResults');
          displayAnalysisResults(message.analysis);
        } else {
          console.error('AI Design Lint: Ошибка анализа:', message.message);
          // Показываем ошибку
          const componentAnalysisPanel = document.getElementById('component-analysis-panel');
          if (componentAnalysisPanel) {
              componentAnalysisPanel.innerHTML = `
                <div style="color: #F44336; text-align: center; padding: 16px; background: #2A2A32; border-radius: 8px;">
                  ${message.message}
              </div>
            `;
            componentAnalysisPanel.style.display = 'block';
          }
          
          // Восстанавливаем кнопку
          const analyzeDesignButton = document.getElementById('analyze-design-button');
          if (analyzeDesignButton) {
            analyzeDesignButton.textContent = 'Анализировать дизайн';
            analyzeDesignButton.disabled = false;
          }
        }
      } else if (message.type === 'layer-highlighted') {
        if (message.success) {
          debugLog('Слой подсвечен:', message.nodeId);
        } else {
          console.error('Ошибка при подсветке слоя:', message.message);
        }
      } else if (message.type === 'component-properties-analysis-result') {
        // Обработка результата анализа свойств компонентов
        const progress = document.getElementById('component-properties-progress');
        const analysis = document.getElementById('component-properties-analysis');
        const progressFill = document.getElementById('component-properties-progress-fill');
        const progressText = document.getElementById('component-properties-progress-text');
        
        if (message.success) {
          // Скрываем прогресс, показываем анализ
          if (progress) {
            progress.style.display = 'none';
          }
          if (analysis) {
            analysis.style.display = 'block';
            displayComponentAnalysis(message.analysis);
          }
          
          debugLog('Component Properties Analysis: Анализ завершен успешно');
        } else {
          // Показываем ошибку
          if (progressText) {
            progressText.textContent = `Ошибка: ${message.error}`;
            progressText.style.color = '#F44336';
          }
          if (progressFill) {
            progressFill.style.backgroundColor = '#F44336';
          }
          
          console.error('Component Properties Analysis: Ошибка анализа:', message.error);
        }
      } else if (message.type === 'component-properties-export-result') {
        // Обработка результата экспорта свойств компонентов
        const progress = document.getElementById('component-properties-progress');
        const results = document.getElementById('component-properties-results');
        const progressFill = document.getElementById('component-properties-progress-fill');
        const progressText = document.getElementById('component-properties-progress-text');
        
        if (message.success) {
          // Скрываем прогресс, показываем результаты
          if (progress) {
            progress.style.display = 'none';
          }
          if (results) {
            results.style.display = 'block';
          }
          
          // Сохраняем данные для скачивания
          window.componentPropertiesJson = message.json;
          window.componentPropertiesCsv = message.csv;
          
          debugLog('Component Properties Export: Экспорт завершен успешно');
        } else {
          // Показываем ошибку
          if (progressText) {
            progressText.textContent = `Ошибка: ${message.error}`;
            progressText.style.color = '#F44336';
          }
          if (progressFill) {
            progressFill.style.backgroundColor = '#F44336';
          }
          
          console.error('Component Properties Export: Ошибка экспорта:', message.error);
        }
      }
    });
    
    // Обработчики для кнопок экспорта
    document.addEventListener('DOMContentLoaded', () => {
      const exportJsonButton = document.getElementById('export-json-button');
      const exportMarkdownButton = document.getElementById('export-markdown-button');
      
      if (exportJsonButton) {
        exportJsonButton.addEventListener('click', () => {
          exportAnalysis('json');
        });
      }
      
      if (exportMarkdownButton) {
        exportMarkdownButton.addEventListener('click', () => {
          exportAnalysis('markdown');
        });
      }
    });

    // ============================================
    // Функции экспорта
    // ============================================
    
    // Экспорт результатов анализа
    function exportAnalysis(format) {
      if (currentAnalysis) {
        if (format === 'json') {
          exportAsJSON(currentAnalysis);
        } else if (format === 'markdown') {
          exportAsMarkdown(currentAnalysis);
        }
      } else {
        alert('Сначала выполните анализ компонента');
      }
    }
    
    // Экспорт в JSON
    function exportAsJSON(analysis) {
      const data = {
        timestamp: new Date().toISOString(),
        componentType: analysis.componentType,
        score: analysis.score,
        totalLayers: analysis.totalLayers,
        tokensUsed: analysis.tokensUsed || [],
        hardcodedValues: analysis.hardcodedValues || [],
        recommendations: analysis.recommendations || [],
        accessibility: analysis.accessibility || {}
      };
      
      const jsonString = JSON.stringify(data, null, 2);
      downloadFile('component-analysis.json', jsonString, 'application/json');
    }
    
    // Экспорт в Markdown
    function exportAsMarkdown(analysis) {
      const timestamp = new Date().toLocaleString('ru-RU');
      
      let markdown = `# Анализ компонента\n\n`;
      markdown += `**Дата анализа:** ${timestamp}\n\n`;
      markdown += `## Общая оценка\n\n`;
      markdown += `- **Оценка:** ${analysis.score}/100\n`;
      markdown += `- **Тип компонента:** ${analysis.componentType}\n`;
      markdown += `- **Всего слоев:** ${analysis.totalLayers}\n\n`;
      
      // Токены
      markdown += `## Использование токенов\n\n`;
      if (analysis.tokensUsed && analysis.tokensUsed.length > 0) {
        markdown += `**Найдено токенов:** ${analysis.tokensUsed.length}\n\n`;
        analysis.tokensUsed.forEach(token => {
          markdown += `- **${token.name}** (${token.type}) - ${token.path}\n`;
        });
      } else {
        markdown += `Токены не найдены\n`;
      }
      markdown += `\n`;
      
      // Hardcoded значения
      markdown += `## Hardcoded значения\n\n`;
      if (analysis.hardcodedValues && analysis.hardcodedValues.length > 0) {
        markdown += `⚠️ **Найдено hardcoded значений:** ${analysis.hardcodedValues.length}\n\n`;
        analysis.hardcodedValues.forEach(item => {
          markdown += `- **${item.type}:** ${item.description} (${JSON.stringify(item.value)})\n`;
        });
      } else {
        markdown += `Hardcoded значения не найдены\n`;
      }
      markdown += `\n`;
      
      // Рекомендации
      markdown += `## Рекомендации\n\n`;
      if (analysis.recommendations && analysis.recommendations.length > 0) {
        analysis.recommendations.forEach(rec => {
          const priority = rec.priority === 'high' ? '🔴' : rec.priority === 'medium' ? '🟡' : '🟢';
          markdown += `${priority} **${rec.priority.toUpperCase()}:** ${rec.message}\n\n`;
        });
      } else {
        markdown += `Компонент соответствует стандартам\n\n`;
      }
      
      // Доступность
      markdown += `## Доступность\n\n`;
      markdown += `- **Текстовые метки:** ${analysis.accessibility?.hasLabels ? 'Да' : 'Нет'}\n`;
      markdown += `- **Alt текст:** ${analysis.accessibility?.hasAltText ? 'Да' : 'Нет'}\n`;
      markdown += `- **Контрастность:** ${analysis.accessibility?.colorContrast || 'неизвестно'}\n\n`;
      
      markdown += `---\n*Сгенерировано плагином Orbita DS ✦ Icons Checker*\n`;
      
      downloadFile('component-analysis.md', markdown, 'text/markdown');
    }
    
    // Функция скачивания файла
    function downloadFile(filename, content, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
    }

    function displayComponentAnalysis(analysis) {
      const statsContainer = document.getElementById('analysis-stats');
      const detailsContainer = document.getElementById('analysis-details');
      
      if (!statsContainer || !detailsContainer) return;
      
      const { summary, componentWithMaxProperties, uniquePropertyNames, breakdown } = analysis;
      
      // Отображаем статистику
      statsContainer.innerHTML = `
        <div class="stat-item">
          <span class="stat-label">Наборов компонентов</span>
          <span class="stat-value">${summary.componentSets}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Компонентов</span>
          <span class="stat-value">${summary.components}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Вариантов</span>
          <span class="stat-value">${summary.totalVariants}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Инстансов</span>
          <span class="stat-value">${summary.instances}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Всего свойств</span>
          <span class="stat-value">${summary.totalProperties}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Уникальных свойств</span>
          <span class="stat-value">${summary.uniqueProperties}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Макс. свойств</span>
          <span class="stat-value">${summary.maxProperties}</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Среднее свойств</span>
          <span class="stat-value">${summary.components > 0 ? Math.round(summary.totalProperties / summary.components) : 0}</span>
        </div>
      `;
      
      // Отображаем детали
      let detailsHtml = '';
      
      if (componentWithMaxProperties) {
        detailsHtml += `
          <h5>Компонент с наибольшим количеством свойств:</h5>
          <ul>
            <li><strong>${componentWithMaxProperties.name}</strong> (${componentWithMaxProperties.type})</li>
            <li>Свойств: ${componentWithMaxProperties.properties}</li>
            ${componentWithMaxProperties.setName ? `<li>Набор: ${componentWithMaxProperties.setName}</li>` : ''}
          </ul>
        `;
      }
      
      if (uniquePropertyNames.length > 0) {
        detailsHtml += `
          <h5>Уникальные свойства (${uniquePropertyNames.length}):</h5>
          <ul>
            ${uniquePropertyNames.slice(0, 10).map(prop => `<li>${prop}</li>`).join('')}
            ${uniquePropertyNames.length > 10 ? `<li>... и еще ${uniquePropertyNames.length - 10}</li>` : ''}
          </ul>
        `;
      }
      
      if (breakdown.componentSetsWithVariants.length > 0) {
        detailsHtml += `
          <h5>Топ наборов по количеству свойств:</h5>
          <ul>
            ${breakdown.componentSetsWithVariants.slice(0, 5).map(cs => 
              `<li><strong>${cs.name}</strong>: ${cs.variants} вариантов, ${cs.totalProperties} свойств</li>`
            ).join('')}
          </ul>
        `;
      }
      
      detailsContainer.innerHTML = detailsHtml;
    }

    // ============================================
    // AI Chat функции
    // ============================================
    
    let currentAnalysis = null;
    let chatHistory = [];
    
    // Инициализация AI чата
    function initializeAIChat() {
      const chatSendButton = document.getElementById('ai-chat-send-button');
      const chatInput = document.getElementById('ai-chat-input');
      
      if (chatSendButton) {
        chatSendButton.addEventListener('click', sendChatMessage);
      }
      
      if (chatInput) {
        chatInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendChatMessage();
          }
        });
      }
    }
    
    // Отправка сообщения в AI чат
    function sendChatMessage() {
      const chatInput = document.getElementById('ai-chat-input');
      const chatHistory = document.getElementById('ai-chat-history');
      const chatSendButton = document.getElementById('ai-chat-send-button');
      
      if (!chatInput || !chatHistory) return;
      
      const message = chatInput.value.trim();
      if (!message) return;
      
      // Добавляем сообщение пользователя в историю
      addMessageToHistory('user', message);
      
      // Очищаем поле ввода
      chatInput.value = '';
      
      // Блокируем кнопку
      if (chatSendButton) {
        chatSendButton.disabled = true;
        chatSendButton.textContent = '⏳ AI думает...';
      }
      
      // Отправляем запрос к Eliza API
      sendToElizaAPI(message);
    }
    
    // Добавление сообщения в историю чата
    function addMessageToHistory(role, content) {
      const chatHistory = document.getElementById('ai-chat-history');
      if (!chatHistory) return;
      
      // Убираем placeholder если есть
      const placeholder = chatHistory.querySelector('[style*="color: #AAAAAA"]');
      if (placeholder) {
        placeholder.remove();
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.style.marginBottom = '6px';
      messageDiv.style.padding = '6px 8px';
      messageDiv.style.borderRadius = '4px';
      messageDiv.style.fontSize = '11px';
      messageDiv.style.lineHeight = '1.4';
      
      if (role === 'user') {
        messageDiv.style.backgroundColor = '#F86025';
        messageDiv.style.color = 'white';
        messageDiv.style.marginLeft = '15px';
        messageDiv.innerHTML = `<strong>Вы:</strong> ${content}`;
      } else {
        messageDiv.style.backgroundColor = '#44444C';
        messageDiv.style.color = 'white';
        messageDiv.style.marginRight = '15px';
        messageDiv.innerHTML = `<strong>AI:</strong> ${content}`;
      }
      
      chatHistory.appendChild(messageDiv);
      chatHistory.scrollTop = chatHistory.scrollHeight;
      
      // Обновляем счетчик сообщений
      updateTokensCount();
    }
    
    // Отправка запроса к Yandex AI (как в основном analyzeWithAI)
    async function sendToElizaAPI(message) {
      try {
        console.log('AI Assistant: Отправка запроса к AI...');
        
        // Получаем токен
        const token = yandexTokenInput ? yandexTokenInput.value.trim() : '';
        if (!token) {
          addMessageToHistory('assistant', '❌ Ошибка: Не настроен Yandex OAuth токен. Перейдите в настройки.');
          return;
        }
        
        // Проверяем наличие анализа
        if (!currentAnalysis) {
          addMessageToHistory('assistant', '❌ Сначала выполните анализ компонента, нажав "Анализировать дизайн"');
          return;
        }
        
        // Формируем контекст для AI
        const context = buildAIContext();
        console.log('AI Assistant: Контекст сформирован');
        
        // Формируем промпт
        const systemPrompt = `Ты - эксперт по дизайн-системам и Figma. 

Контекст анализа компонента:
${context}

Отвечай кратко и по делу. Давай конкретные рекомендации со ссылками на токены из дизайн-системы Orbita.`;

        // Отправляем запрос к Yandex API (как в основной функции)
        const response = await fetch('https://api.eliza.yandex.net/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'yandexgpt-lite',
            messages: [
              {
                role: 'system',
                content: systemPrompt
              },
              {
                role: 'user',
                content: message
              }
            ],
            temperature: 0.6,
            maxTokens: 500
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('AI Assistant: Ошибка API:', response.status, errorText);
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('AI Assistant: Ответ получен:', data);
        
        // Извлекаем ответ (как в основной функции)
        const aiResponse = data.result?.alternatives?.[0]?.message?.text || 
                          data.choices?.[0]?.message?.content ||
                          'Извините, не удалось получить ответ от AI.';
        
        addMessageToHistory('assistant', aiResponse);
        
      } catch (error) {
        console.error('AI Assistant: Ошибка:', error);
        addMessageToHistory('assistant', `❌ Ошибка: ${error.message}`);
      } finally {
        // Разблокируем кнопку
        const chatSendButton = document.getElementById('ai-chat-send-button');
        if (chatSendButton) {
          chatSendButton.disabled = false;
          chatSendButton.textContent = '💬 Задать вопрос AI';
        }
      }
    }
    
    // Построение контекста для AI
    function buildAIContext() {
      if (!currentAnalysis) return 'Анализ не выполнен';
      
      return JSON.stringify({
        score: currentAnalysis.score,
        totalLayers: currentAnalysis.totalLayers,
        tokensUsed: currentAnalysis.tokensUsed?.length || 0,
        hardcodedValues: currentAnalysis.hardcodedValues?.length || 0,
        recommendations: currentAnalysis.recommendations?.length || 0,
        componentType: currentAnalysis.componentType
      });
    }
    
    // Обновление счетчика токенов
    function updateTokensCount() {
      const tokensCount = document.getElementById('ai-chat-tokens-count');
      const tokensInfo = document.getElementById('ai-chat-tokens-info');
      
      if (tokensCount) {
        const count = chatHistory.length;
        tokensCount.textContent = count;
      }
      
      if (tokensInfo) {
        tokensInfo.style.display = chatHistory.length > 0 ? 'block' : 'none';
      }
    }
    
    // Инициализация при загрузке
    document.addEventListener('DOMContentLoaded', initializeAIChat);
    
    
  </script>
</body>
</html>